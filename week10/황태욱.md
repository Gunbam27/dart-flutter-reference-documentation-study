# Understanding constraints

_Note_
If you are experiencing specific layout errors, you might check out [Common Flutter errors](https://docs.flutter.dev/testing/common-errors).

When someone learning Flutter asks you why some widget with `width: 100` isn't 100 pixels wide, the default answer is to tell them to put that widget inside of a `Center`, right?

_정보_
"만약 여러분이 특정 레이아웃 오류를 겪고 있다면, [Common Flutter errors](https://docs.flutter.dev/testing/common-errors)를 확인해 보세요.

Flutter를 배우는 누군가가 `width: 100`인 위젯이 왜 100픽셀이 아닌지 묻는다면, 그 위젯을 `Center` 안에 넣으라고 기본적으로 답해줘야 하나요?"

**Don't do that.**

If you do, they'll come back again and again, asking why some `FittedBox` isn't working, why that `Column` is overflowing, or what `IntrinsicWidth` is supposed to be doing.

Instead, first tell them that Flutter layout is very different from HTML layout (which is probably where they're coming from), and then make them memorize the following rule:

**그렇게 하지 마세요.**

그렇게 하면 그들이 FittedBox가 왜 작동하지 않는지, Column이 왜 오버플로우하는지, 또는 IntrinsicWidth가 무엇을 해야 하는지에 대해 계속 질문하게 될 것입니다.

대신, 먼저 Flutter 레이아웃이 HTML 레이아웃과 매우 다르다는 것을 알려주고, 다음 규칙을 암기하도록 하세요:

**Constraints go down. Sizes go up. Parent sets position.**

Flutter layout can't really be understood without knowing this rule, so Flutter developers should learn it early on.

In more detail:

- A widget gets its own **constraints** from its **parent**. A _constraint_ is just a set of 4 doubles: a minimum and maximum width, and a minimum and maximum height.
- Then the widget goes through its own list of **children**. One by one, the widget tells its children what their **constraints** are (which can be different for each child), and then asks each child what size it wants to be.
- Then, the widget positions its **children** (horizontally in the `x` axis, and vertically in the `y` axis), one by one.
- And, finally, the widget tells its parent about its own **size** (within the original constraints, of course).

For example, if a composed widget contains a column with some padding, and wants to lay out its two children as follows:

**제약 조건은 아래로 내려가고, 크기는 위로 올라갑니다. 부모가 위치를 설정합니다.**
이 규칙을 알지 못하면 Flutter 레이아웃을 제대로 이해할 수 없기 때문에, Flutter 개발자는 이 규칙을 일찍 배워야 합니다.

좀 더 자세히 설명하자면:

위젯은 부모로부터 자신의 제약 조건을 받습니다. 제약 조건은 4개의 double 값 세트, 즉 최소 및 최대 너비, 그리고 최소 및 최대 높이에 불과합니다. 그런 다음, 위젯은 자신의 자식 목록을 하나씩 훑어봅니다. 차례로, 위젯은 자식에게 그들의 제약 조건이 무엇인지 알려주고(자식마다 다를 수 있음), 그런 다음 각 자식에게 자신이 원하는 크기를 묻습니다. 그런 다음, 위젯은 자식들을 하나씩 위치시킵니다(수평적으로는 x 축에서, 수직적으로는 y 축에서). 그리고 마지막으로, 위젯은 자신의 크기를 부모에게 알려줍니다(물론 원래의 제약 조건 내에서). 예를 들어, 하나의 구성된 위젯이 일부 패딩이 있는 열을 포함하고 있으며, 자식 두 개를 다음과 같이 배치하려고 한다고 가정해봅시다:
![Visual layout](https://docs.flutter.dev/assets/images/docs/ui/layout/children.png)

The negotiation goes something like this:

**Widget**: "Hey parent, what are my constraints?"

**Parent**: "You must be from `0` to `300` pixels wide, and `0` to `85` tall."

**Widget**: "Hmmm, since I want to have `5` pixels of padding, then my children can have at most `290` pixels of width and `75` pixels of height."

**Widget**: "Hey first child, You must be from `0` to `290` pixels wide, and `0` to `75` tall."

**First child**: "OK, then I wish to be `290` pixels wide, and `20` pixels tall."

**Widget**: "Hmmm, since I want to put my second child below the first one, this leaves only `55` pixels of height for my second child."

**Widget**: "Hey second child, You must be from `0` to `290` wide, and `0` to `55` tall."

**Second child**: "OK, I wish to be `140` pixels wide, and `30` pixels tall."

**Widget**: "Very well. My first child has position `x: 5` and `y: 5`, and my second child has `x: 80` and `y: 25`."

**Widget**: "Hey parent, I've decided that my size is going to be `300` pixels wide, and `60` pixels tall."

협상은 다음과 같이 진행됩니다:

위젯: '부모님, 제 제약 조건은 무엇인가요?'

부모: '너는 0에서 300픽셀 너비, 0에서 85픽셀 높이를 가져야 한다.'

위젯: '음, 나는 5픽셀의 패딩을 원하니까, 내 자식들은 최대 290픽셀 너비와 75픽셀 높이를 가질 수 있겠군.'

위젯: '첫 번째 자식아, 너는 0에서 290픽셀 너비, 0에서 75픽셀 높이를 가져야 한다.'

첫 번째 자식: '알겠어요, 그러면 저는 290픽셀 너비와 20픽셀 높이를 원합니다.'

위젯: '음, 두 번째 자식을 첫 번째 자식 아래에 배치하고 싶으니까, 두 번째 자식에게는 55픽셀 높이만 남겠군.'

위젯: '두 번째 자식아, 너는 0에서 290픽셀 너비, 0에서 55픽셀 높이를 가져야 한다.'

두 번째 자식: '알겠어요, 저는 140픽셀 너비와 30픽셀 높이를 원합니다.'

위젯: '좋아. 첫 번째 자식은 x: 5, y: 5 위치에 있고, 두 번째 자식은 x: 80, y: 25 위치에 있구나.'

위젯: '부모님, 제가 결정한 크기는 300픽셀 너비, 60픽셀 높이입니다.'

## Limitations

Flutter's layout engine is designed to be a one-pass process. This means that Flutter lays out its widgets very efficiently, but does result in a few limitations:

- A widget can decide its own size only within the constraints given to it by its parent. This means a widget usually **can't have any size it wants**.
    
- A widget **can't know and doesn't decide its own position in the screen**, since it's the widget's parent who decides the position of the widget.
    
- Since the parent's size and position, in its turn, also depends on its own parent, it's impossible to precisely define the size and position of any widget without taking into consideration the tree as a whole.
    
- If a child wants a different size from its parent and the parent doesn't have enough information to align it, then the child's size might be ignored. **Be specific when defining alignment.**
    

In Flutter, widgets are rendered by their underlying [`RenderBox`](https://api.flutter.dev/flutter/rendering/RenderBox-class.html) objects. Many boxes in Flutter, especially those that just take a single child, pass their constraint on to their children.

Generally, there are three kinds of boxes, in terms of how they handle their constraints:

- Those that try to be as big as possible. For example, the boxes used by [`Center`](https://api.flutter.dev/flutter/widgets/Center-class.html) and [`ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html).
- Those that try to be the same size as their children. For example, the boxes used by [`Transform`](https://api.flutter.dev/flutter/widgets/Transform-class.html) and [`Opacity`](https://api.flutter.dev/flutter/widgets/Opacity-class.html).
- Those that try to be a particular size. For example, the boxes used by [`Image`](https://api.flutter.dev/flutter/dart-ui/Image-class.html) and [`Text`](https://api.flutter.dev/flutter/widgets/Text-class.html).

Some widgets, for example [`Container`](https://api.flutter.dev/flutter/widgets/Container-class.html), vary from type to type based on their constructor arguments. The [`Container`](https://api.flutter.dev/flutter/widgets/Container-class.html) constructor defaults to trying to be as big as possible, but if you give it a `width`, for instance, it tries to honor that and be that particular size.

Others, for example [`Row`](https://api.flutter.dev/flutter/widgets/Row-class.html) and [`Column`](https://api.flutter.dev/flutter/widgets/Column-class.html) (flex boxes) vary based on the constraints they are given, as described in the [Flex](https://docs.flutter.dev/ui/layout/constraints#flex) section.

## 제약 사항

Flutter의 레이아웃 엔진은 한 번의 과정으로 설계되었습니다. 이는 Flutter가 위젯을 매우 효율적으로 레이아웃하지만, 몇 가지 제약이 발생한다는 것을 의미합니다:

- 위젯은 부모가 제공한 제약 조건 내에서만 자신의 크기를 결정할 수 있습니다. 즉, 위젯은 보통 원하는 크기를 가질 수 없습니다.

- 위젯은 화면에서 자신의 위치를 알 수 없으며, 그 위치를 결정하지도 않습니다. 위젯의 위치는 부모가 결정하기 때문입니다.

- 부모의 크기와 위치 또한 부모의 부모에 의존하기 때문에, 트리 전체를 고려하지 않고는 어떤 위젯의 크기와 위치를 정확하게 정의할 수 없습니다.

- 자식이 부모와 다른 크기를 원하고, 부모가 이를 맞출 수 있는 충분한 정보를 가지고 있지 않다면, 자식의 크기는 무시될 수 있습니다. 정렬을 정의할 때는 구체적으로 지정하세요.

Flutter에서 위젯은 기본적으로 RenderBox 객체에 의해 렌더링됩니다. 많은 상자들(특히 자식 하나만 받는 상자들)은 자신의 제약 조건을 자식에게 전달합니다.

일반적으로, 제약 조건을 처리하는 방식에 따라 상자는 세 가지 종류로 나뉩니다:

- 최대한 크게 되려고 하는 상자들. 예를 들어, Center와 ListView에서 사용되는 상자들.
- 자식과 같은 크기를 유지하려고 하는 상자들. 예를 들어, Transform과 Opacity에서 사용되는 상자들.
- 특정 크기를 가지려고 하는 상자들. 예를 들어, Image와 Text에서 사용되는 상자들.

일부 위젯, 예를 들어 Container는 생성자 인수에 따라 타입이 달라집니다. Container 생성자는 기본적으로 최대한 크게 되려고 하지만, 예를 들어 너비를 지정하면, 그 크기를 존중하고 지정된 크기가 되려고 합니다.

또한 Row와 Column(플렉스 박스)과 같은 위젯은 Flex 섹션에서 설명한 것처럼 주어진 제약 조건에 따라 달라집니다

## Examples

For an interactive experience, use the following DartPad. Use the numbered horizontal scrolling bar to switch between 29 different examples.

If you prefer, you can grab the code from [this GitHub repo](https://github.com/marcglasberg/flutter_layout_article).

The examples are explained in the following sections.

## 예제

인터랙티브한 경험을 원하신다면, 아래의 DartPad를 사용하세요. 번호가 매겨진 수평 스크롤 바를 사용하여 29가지 다른 예제를 전환할 수 있습니다.

선호하신다면, 이 GitHub 저장소에서 코드를 가져올 수도 있습니다.

예제에 대한 설명은 다음 섹션에서 다룹니다.

### Example 1

![Example 1 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-1.png)

```dart
Container(color: red)
```

The screen is the parent of the `Container`, and it forces the `Container` to be exactly the same size as the screen.

So the `Container` fills the screen and paints it red.

"화면이 `Container`의 부모이며, `Container`에게 화면과 정확히 동일한 크기가 되도록 강제합니다.

따라서 `Container`는 화면을 채우고 빨간색으로 칠해집니다."

### Example 2

![Example 2 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-2.png)

```dart
Container(width: 100, height: 100, color: red)
```


The red `Container` wants to be 100 × 100, but it can't, because the screen forces it to be exactly the same size as the screen.

So the `Container` fills the screen.

빨간 컨테이너는 100 × 100이 되기를 원하지만, 화면이 컨테이너를 화면과 정확히 같은 크기로 강제하기 때문에 그렇게 할 수 없습니다.

그래서 컨테이너는 화면을 가득 채웁니다.

### Example 3

![Example 3 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-3.png)

```dart
Center(
  child: Container(width: 100, height: 100, color: red),
)
```

The screen forces the `Center` to be exactly the same size as the screen, so the `Center` fills the screen.

The `Center` tells the `Container` that it can be any size it wants, but not bigger than the screen. Now the `Container` can indeed be 100 × 100.

화면이 센터를 화면과 정확히 같은 크기로 강제하기 때문에 센터는 화면을 가득 채웁니다.

센터는 컨테이너에게 화면보다 클 수는 없지만 원하는 크기로 설정할 수 있다고 말합니다. 이제 컨테이너는 실제로 100 × 100이 될 수 있습니다.

### Example 4

![Example 4 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-4.png)

```dart
Align(
  alignment: Alignment.bottomRight,
  child: Container(width: 100, height: 100, color: red),
)
```

This is different from the previous example in that it uses `Align` instead of `Center`.

`Align` also tells the `Container` that it can be any size it wants, but if there is empty space it won't center the `Container`. Instead, it aligns the container to the bottom-right of the 
available space.

이것은 이전 예제와 다른 점이, `Center` 대신 `Align`을 사용한다는 것입니다.

`Align`도 컨테이너가 원하는 크기로 설정할 수 있다고 말하지만, 빈 공간이 있을 경우 컨테이너를 중앙에 배치하지 않습니다. 대신, 사용 가능한 공간의 오른쪽 하단에 컨테이너를 정렬합니다.

### Example 5

![Example 5 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-5.png)


```dart
Center(
  child: Container(
      width: double.infinity, height: double.infinity, color: red),
)
```

The screen forces the `Center` to be exactly the same size as the screen, so the `Center` fills the screen.

The `Center` tells the `Container` that it can be any size it wants, but not bigger than the screen. The `Container` wants to be of infinite size, but since it can't be bigger than the screen, it just fills the screen.

화면이 `Center`를 화면과 정확히 같은 크기로 강제하기 때문에 `Center`는 화면을 가득 채웁니다.

`Center`는 컨테이너에게 화면보다 클 수는 없지만 원하는 크기로 설정할 수 있다고 말합니다. 컨테이너는 무한한 크기를 원하지만 화면보다 커질 수 없기 때문에, 결국 화면을 가득 채웁니다.
### Example 6

![Example 6 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-6.png)

```dart
Center(
  child: Container(color: red),
)
```


The screen forces the `Center` to be exactly the same size as the screen, so the `Center` fills the screen.

The `Center` tells the `Container` that it can be any size it wants, but not bigger than the screen. Since the `Container` has no child and no fixed size, it decides it wants to be as big as possible, so it fills the whole screen.

But why does the `Container` decide that? Simply because that's a design decision by those who created the `Container` widget. It could have been created differently, and you have to read the [`Container`](https://api.flutter.dev/flutter/widgets/Container-class.html) API documentation to understand how it behaves, depending on the circumstances.

화면이 `Center`를 화면과 정확히 같은 크기로 강제하기 때문에, `Center`는 화면을 가득 채웁니다.

`Center`는 컨테이너에게 화면보다 클 수는 없지만 원하는 크기로 설정할 수 있다고 말합니다. 컨테이너는 자식이 없고 고정된 크기가 없기 때문에 가능한 최대 크기를 원하며, 그래서 전체 화면을 가득 채우게 됩니다.

그런데 컨테이너가 그렇게 결정하는 이유는 무엇일까요? 단순히 컨테이너 위젯을 만든 사람들이 그렇게 디자인했기 때문입니다. 컨테이너가 다르게 만들어졌을 수도 있으며, 컨테이너의 동작 방식은 상황에 따라 다를 수 있으므로 컨테이너 API 문서를 읽어봐야 이해할 수 있습니다.

### Example 7

![Example 7 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-7.png)


```dart
Center(
  child: Container(
    color: red,
    child: Container(color: green, width: 30, height: 30),
  ),
)
```

The screen forces the `Center` to be exactly the same size as the screen, so the `Center` fills the screen.

The `Center` tells the red `Container` that it can be any size it wants, but not bigger than the screen. Since the red `Container` has no size but has a child, it decides it wants to be the same size as its child.

The red `Container` tells its child that it can be any size it wants, but not bigger than the screen.

The child is a green `Container` that wants to be 30 × 30. Given that the red `Container` sizes itself to the size of its child, it is also 30 × 30. The red color isn't visible because the green `Container` entirely covers the red `Container`.

화면이 `Center`를 화면과 정확히 같은 크기로 강제하기 때문에 `Center`는 화면을 가득 채웁니다.

`Center`는 빨간색 컨테이너에게 화면보다 클 수는 없지만 원하는 크기로 설정할 수 있다고 말합니다. 빨간색 컨테이너는 크기가 없지만 자식이 있으므로, 자식과 같은 크기를 원합니다.

빨간색 컨테이너는 자식에게 화면보다 클 수는 없지만 원하는 크기로 설정할 수 있다고 말합니다.

자식은 30 × 30 크기를 원하는 초록색 컨테이너입니다. 빨간색 컨테이너가 자식의 크기에 맞춰 크기를 조정하므로, 빨간색 컨테이너도 30 × 30이 됩니다. 초록색 컨테이너가 빨간색 컨테이너를 완전히 덮기 때문에 빨간색은 보이지 않게 됩니다.

### Example 8

![Example 8 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-8.png)

```dart
Center(
  child: Container(
    padding: const EdgeInsets.all(20),
    color: red,
    child: Container(color: green, width: 30, height: 30),
  ),
)
```

The red `Container` sizes itself to its children's size, but it takes its own padding into consideration. So it is also 30 × 30 plus padding. The red color is visible because of the padding, and the green `Container` has the same size as in the previous example.

빨간색 컨테이너는 자식의 크기에 맞춰 크기를 조정하지만, 자신의 패딩을 고려합니다. 그래서 빨간색 컨테이너는 30 × 30에 패딩을 더한 크기가 됩니다. 패딩 때문에 빨간색이 보이게 되며, 초록색 컨테이너는 이전 예제와 동일한 크기인 30 × 30을 유지합니다.

### Example 9

![Example 9 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-9.png)

```dart
ConstrainedBox(
  constraints: const BoxConstraints(
    minWidth: 70,
    minHeight: 70,
    maxWidth: 150,
    maxHeight: 150,
  ),
  child: Container(color: red, width: 10, height: 10),
)
```

You might guess that the `Container` has to be between 70 and 150 pixels, but you would be wrong. The `ConstrainedBox` only imposes **additional** constraints from those it receives from its parent.

Here, the screen forces the `ConstrainedBox` to be exactly the same size as the screen, so it tells its child `Container` to also assume the size of the screen, thus ignoring its `constraints` parameter.

컨테이너가 70에서 150픽셀 사이여야 한다고 추측할 수도 있지만, 그것은 틀린 추측입니다. `ConstrainedBox`는 부모로부터 받은 제약 조건에 추가적인 제약만을 부과합니다.

여기서 화면이 `ConstrainedBox`를 화면과 정확히 같은 크기로 강제하기 때문에, `ConstrainedBox`는 자식 컨테이너에게도 화면과 같은 크기를 가지라고 지시하게 됩니다. 따라서 제약 조건 매개변수는 무시됩니다.

### Example 10

![Example 10 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-10.png)

```dart
Center(
  child: ConstrainedBox(
    constraints: const BoxConstraints(
      minWidth: 70,
      minHeight: 70,
      maxWidth: 150,
      maxHeight: 150,
    ),
    child: Container(color: red, width: 10, height: 10),
  ),
)
```

Now, `Center` allows `ConstrainedBox` to be any size up to the screen size. The `ConstrainedBox` imposes **additional** constraints from its `constraints` parameter onto its child.

The Container must be between 70 and 150 pixels. It wants to have 10 pixels, so it ends up having 70 (the minimum).

이제 `Center`는 `ConstrainedBox`가 화면 크기까지의 크기를 가질 수 있도록 허용합니다. `ConstrainedBox`는 자신의 `constraints` 매개변수로 자식에게 추가적인 제약 조건을 부과합니다.

컨테이너는 70에서 150픽셀 사이여야 합니다. 컨테이너가 10픽셀을 가지기를 원하지만, 제약 조건에 따라 최소 크기인 70픽셀을 가지게 됩니다.

### Example 11

![Example 11 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-11.png)

```dart
Center(
  child: ConstrainedBox(
    constraints: const BoxConstraints(
      minWidth: 70,
      minHeight: 70,
      maxWidth: 150,
      maxHeight: 150,
    ),
    child: Container(color: red, width: 1000, height: 1000),
  ),
)
```

`Center` allows `ConstrainedBox` to be any size up to the screen size. The `ConstrainedBox` imposes **additional** constraints from its `constraints` parameter onto its child.

The `Container` must be between 70 and 150 pixels. It wants to have 1000 pixels, so it ends up having 150 (the maximum).

`Center`는 `ConstrainedBox`가 화면 크기까지의 크기를 가질 수 있도록 허용합니다. `ConstrainedBox`는 자신의 `constraints` 매개변수로 자식에게 추가적인 제약 조건을 부과합니다.

컨테이너는 70에서 150픽셀 사이여야 합니다. 컨테이너가 1000픽셀을 원하지만, 제약 조건으로 인해 최대 크기인 150픽셀을 가지게 됩니다.

### Example 12

![Example 12 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-12.png)

```dart
Center(
  child: ConstrainedBox(
    constraints: const BoxConstraints(
      minWidth: 70,
      minHeight: 70,
      maxWidth: 150,
      maxHeight: 150,
    ),
    child: Container(color: red, width: 100, height: 100),
  ),
)
```

`Center` allows `ConstrainedBox` to be any size up to the screen size. The `ConstrainedBox` imposes **additional** constraints from its `constraints` parameter onto its child.

The `Container` must be between 70 and 150 pixels. It wants to have 100 pixels, and that's the size it has, since that's between 70 and 150.

`Center`는 `ConstrainedBox`가 화면 크기까지의 크기를 가질 수 있도록 허용합니다. `ConstrainedBox`는 자신의 `constraints` 매개변수로 자식에게 추가적인 제약 조건을 부과합니다.

컨테이너는 70에서 150픽셀 사이여야 합니다. 컨테이너가 100픽셀을 원하고, 100픽셀은 70과 150 사이에 있으므로 컨테이너는 100픽셀의 크기를 가지게 됩니다.

### Example 13

![Example 13 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-13.png)


```dart
UnconstrainedBox(
  child: Container(color: red, width: 20, height: 50),
)
```

The screen forces the `UnconstrainedBox` to be exactly the same size as the screen. However, the `UnconstrainedBox` lets its child `Container` be any size it wants.

화면이 `UnconstrainedBox`를 화면과 정확히 같은 크기로 강제합니다. 그러나 `UnconstrainedBox`는 자식 컨테이너가 원하는 크기를 가질 수 있도록 허용합니다.

### Example 14

![Example 14 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-14.png)

```dart
UnconstrainedBox(
  child: Container(color: red, width: 4000, height: 50),
)
```

The screen forces the `UnconstrainedBox` to be exactly the same size as the screen, and `UnconstrainedBox` lets its child `Container` be any size it wants.

Unfortunately, in this case the `Container` is 4000 pixels wide and is too big to fit in the `UnconstrainedBox`, so the `UnconstrainedBox` displays the much dreaded "overflow warning".

화면이 `UnconstrainedBox`를 화면과 정확히 같은 크기로 강제하고, `UnconstrainedBox`는 자식 컨테이너가 원하는 크기를 가질 수 있도록 허용합니다.

불행히도, 이 경우 컨테이너가 4000픽셀 너비로 너무 커서 `UnconstrainedBox`에 맞지 않기 때문에, `UnconstrainedBox`는 매우 걱정스러운 "오버플로우 경고"를 표시합니다.
### Example 15

![Example 15 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-15.png)

```dart
OverflowBox(
  minWidth: 0,
  minHeight: 0,
  maxWidth: double.infinity,
  maxHeight: double.infinity,
  child: Container(color: red, width: 4000, height: 50),
)
```

The screen forces the `OverflowBox` to be exactly the same size as the screen, and `OverflowBox` lets its child `Container` be any size it wants.

`OverflowBox` is similar to `UnconstrainedBox`; the difference is that it won't display any warnings if the child doesn't fit the space.

In this case, the `Container` has 4000 pixels of width, and is too big to fit in the `OverflowBox`, but the `OverflowBox` simply shows as much as it can, with no warnings given.

화면이 `OverflowBox`를 화면과 정확히 같은 크기로 강제하며, `OverflowBox`는 자식 컨테이너가 원하는 크기를 가질 수 있도록 허용합니다.

`OverflowBox`는 `UnconstrainedBox`와 유사하지만, 자식이 공간에 맞지 않을 때 경고를 표시하지 않는 점이 다릅니다.

이 경우, 컨테이너가 4000픽셀 너비로 너무 커서 `OverflowBox`에 맞지 않지만, `OverflowBox`는 가능한 만큼만 표시하며 경고는 표시하지 않습니다.

### Example 16

![Example 16 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-16.png)

```dart
UnconstrainedBox(
  child: Container(color: Colors.red, width: double.infinity, height: 100),
)
```

This won't render anything, and you'll see an error in the console.

The `UnconstrainedBox` lets its child be any size it wants, however its child is a `Container` with infinite size.

Flutter can't render infinite sizes, so it throws an error with the following message: `BoxConstraints forces an infinite width.`

이 경우는 아무 것도 렌더링되지 않으며, 콘솔에서 오류가 표시됩니다.

`UnconstrainedBox`는 자식이 원하는 크기를 가질 수 있도록 허용하지만, 자식이 무한한 크기를 가진 컨테이너인 경우가 있습니다.

Flutter는 무한한 크기를 렌더링할 수 없으므로, 다음과 같은 오류 메시지를 던집니다: `BoxConstraints forces an infinite width.`
### Example 17

![Example 17 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-17.png)

```dart
UnconstrainedBox(
  child: LimitedBox(
    maxWidth: 100,
    child: Container(
      color: Colors.red,
      width: double.infinity,
      height: 100,
    ),
  ),
)
```

Here you won't get an error anymore, because when the `LimitedBox` is given an infinite size by the `UnconstrainedBox`; it passes a maximum width of 100 down to its child.

If you swap the `UnconstrainedBox` for a `Center` widget, the `LimitedBox` won't apply its limit anymore (since its limit is only applied when it gets infinite constraints), and the width of the `Container` is allowed to grow past 100.

This explains the difference between a `LimitedBox` and a `ConstrainedBox`.

이제 오류가 발생하지 않습니다. 이유는 `UnconstrainedBox`가 무한한 크기를 `LimitedBox`에 제공하면, `LimitedBox`가 최대 너비 100을 자식에게 전달하기 때문입니다.

`UnconstrainedBox`를 `Center` 위젯으로 바꾸면, `LimitedBox`는 무한 제약을 받을 때만 제한을 적용하므로, `Center`가 무한한 크기를 제공하면 `LimitedBox`의 제한이 적용되지 않습니다. 따라서 컨테이너의 너비가 100을 넘어서도 됩니다.

이로써 `LimitedBox`와 `ConstrainedBox`의 차이를 이해할 수 있습니다. `LimitedBox`는 무한 제약을 받을 때만 제한을 적용하는 반면, `ConstrainedBox`는 항상 제약을 적용합니다.

### Example 18

![Example 18 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-18.png)

```dart
const FittedBox(
  child: Text('Some Example Text.'),
)
```

The screen forces the `FittedBox` to be exactly the same size as the screen. The `Text` has some natural width (also called its intrinsic width) that depends on the amount of text, its font size, and so on.

The `FittedBox` lets the `Text` be any size it wants, but after the `Text` tells its size to the `FittedBox`, the `FittedBox` scales the Text until it fills all of the available width.

화면은 `FittedBox`가 화면과 정확히 동일한 크기가 되도록 강제합니다. `Text`는 텍스트의 양, 글꼴 크기 등에 따라 자연적인 너비(고유 너비라고도 함)를 가지게 됩니다.

`FittedBox`는 `Text`가 원하는 크기일 수 있도록 허용하지만, `Text`가 `FittedBox`에게 자신의 크기를 알려준 후, `FittedBox`는 사용 가능한 모든 너비를 채울 때까지 `Text`를 확장합니다.

### Example 19

![Example 19 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-19.png)

```dart
const Center(
  child: FittedBox(
    child: Text('Some Example Text.'),
  ),
)
```

But what happens if you put the `FittedBox` inside of a `Center` widget? The `Center` lets the `FittedBox` be any size it wants, up to the screen size.

The `FittedBox` then sizes itself to the `Text`, and lets the `Text` be any size it wants. Since both `FittedBox` and the `Text` have the same size, no scaling happens.

그러나 `FittedBox`를 `Center` 위젯 안에 넣으면 어떻게 될까요? `Center`는 `FittedBox`가 원하는 크기가 되도록 허용하며, 그 크기는 화면 크기까지 가능합니다.

이후 `FittedBox`는 `Text`에 맞게 크기를 조정하고, `Text`가 원하는 크기가 되도록 합니다. `FittedBox`와 `Text`가 동일한 크기를 가지게 되므로, 크기 조정은 발생하지 않습니다.
### Example 20

![Example 20 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-20.png)

```dart
const Center(
  child: FittedBox(
    child: Text(
        'This is some very very very large text that is too big to fit a regular screen in a single line.'),
  ),
)
```

However, what happens if `FittedBox` is inside of a `Center` widget, but the `Text` is too large to fit the screen?

`FittedBox` tries to size itself to the `Text`, but it can't be bigger than the screen. It then assumes the screen size, and resizes `Text` so that it fits the screen, too.

하지만 `FittedBox`가 `Center` 위젯 안에 있고, `Text`가 화면에 맞지 않을 정도로 너무 큰 경우에는 어떻게 될까요?

`FittedBox`는 `Text`에 맞춰 자신을 조정하려고 하지만, 화면보다 커질 수는 없습니다. 그래서 `FittedBox`는 화면 크기를 취하고, `Text`도 화면에 맞도록 크기를 조정합니다.
### Example 21

![Example 21 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-21.png)

```dart
const Center(
  child: Text(
      'This is some very very very large text that is too big to fit a regular screen in a single line.'),
)
```

If, however, you remove the `FittedBox`, the `Text` gets its maximum width from the screen, and breaks the line so that it fits the screen.

그러나 `FittedBox`를 제거하면, `Text`는 화면에서 최대 너비를 가져와 화면에 맞도록 줄을 나누게 됩니다.
### Example 22

![Example 22 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-22.png)

```dart
FittedBox(
  child: Container(
    height: 20,
    width: double.infinity,
    color: Colors.red,
  ),
)
```

`FittedBox` can only scale a widget that is bounded (has non-infinite width and height). Otherwise, it won't render anything, and you'll see an error in the console.

`FittedBox`는 제한된 크기(무한하지 않은 너비와 높이)를 가진 위젯만 크기 조정할 수 있습니다. 그렇지 않으면 아무것도 렌더링되지 않으며, 콘솔에서 오류 메시지를 볼 수 있습니다.
### Example 23

![Example 23 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-23.png)

```dart
Row(
  children: [
    Container(color: red, child: const Text('Hello!', style: big)),
    Container(color: green, child: const Text('Goodbye!', style: big)),
  ],
)
```

The screen forces the `Row` to be exactly the same size as the screen.

Just like an `UnconstrainedBox`, the `Row` won't impose any constraints onto its children, and instead lets them be any size they want. The `Row` then puts them side-by-side, and any extra space remains empty.

화면은 `Row`가 화면과 정확히 동일한 크기가 되도록 강제합니다.

`UnconstrainedBox`와 마찬가지로, `Row`는 자식들에게 아무런 제약을 가하지 않고, 대신 그들이 원하는 크기가 되도록 허용합니다. 그런 다음 `Row`는 자식들을 나란히 배치하고, 남은 여분의 공간은 빈 상태로 남게 됩니다.
### Example 24

![Example 24 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-24.png)

```dart
Row(
  children: [
    Container(
      color: red,
      child: const Text(
        'This is a very long text that '
        'won\'t fit the line.',
        style: big,
      ),
    ),
    Container(color: green, child: const Text('Goodbye!', style: big)),
  ],
)
```

Since `Row` won't impose any constraints onto its children, it's quite possible that the children might be too big to fit the available width of the `Row`. In this case, just like an `UnconstrainedBox`, the `Row` displays the "overflow warning".

`Row`는 자식들에게 아무런 제약을 가하지 않기 때문에, 자식들이 `Row`의 사용 가능한 너비에 맞지 않을 정도로 너무 클 수 있습니다. 이 경우, `UnconstrainedBox`와 마찬가지로 `Row`는 "오버플로 경고"를 표시합니다.
### Example 25

![Example 25 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-25.png)

```dart
Row(
  children: [
    Expanded(
      child: Center(
        child: Container(
          color: red,
          child: const Text(
            'This is a very long text that won\'t fit the line.',
            style: big,
          ),
        ),
      ),
    ),
    Container(color: green, child: const Text('Goodbye!', style: big)),
  ],
)
```

When a `Row`'s child is wrapped in an `Expanded` widget, the `Row` won't let this child define its own width anymore.

Instead, it defines the `Expanded` width according to the other children, and only then the `Expanded` widget forces the original child to have the `Expanded`'s width.

In other words, once you use `Expanded`, the original child's width becomes irrelevant, and is ignored.

`Row`의 자식이 `Expanded` 위젯으로 감싸여 있으면, `Row`는 더 이상 해당 자식이 자신의 너비를 정의하지 못하게 합니다.

대신, `Row`는 다른 자식들의 너비를 기준으로 `Expanded`의 너비를 정의하고, 그런 다음 `Expanded` 위젯이 원래 자식에게 `Expanded`의 너비를 강제로 적용합니다.

즉, `Expanded`를 사용하면 원래 자식의 너비는 더 이상 중요하지 않으며, 무시됩니다.

### Example 26

![Example 26 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-26.png)

```dart
Row(
  children: [
    Expanded(
      child: Container(
        color: red,
        child: const Text(
          'This is a very long text that won\'t fit the line.',
          style: big,
        ),
      ),
    ),
    Expanded(
      child: Container(
        color: green,
        child: const Text(
          'Goodbye!',
          style: big,
        ),
      ),
    ),
  ],
)
```

If all of `Row`'s children are wrapped in `Expanded` widgets, each `Expanded` has a size proportional to its flex parameter, and only then each `Expanded` widget forces its child to have the `Expanded`'s width.

In other words, `Expanded` ignores the preferred width of its children.

`Row`의 모든 자식이 `Expanded` 위젯으로 감싸여 있으면, 각 `Expanded`는 자신의 flex 파라미터에 비례한 크기를 갖게 되며, 그런 다음 각 `Expanded` 위젯이 자식에게 `Expanded`의 너비를 강제로 적용합니다.

즉, `Expanded`는 자식의 선호 너비를 무시합니다.
### Example 27

![Example 27 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-27.png)

```dart
Row(
  children: [
    Flexible(
      child: Container(
        color: red,
        child: const Text(
          'This is a very long text that won\'t fit the line.',
          style: big,
        ),
      ),
    ),
    Flexible(
      child: Container(
        color: green,
        child: const Text(
          'Goodbye!',
          style: big,
        ),
      ),
    ),
  ],
)
```

The only difference if you use `Flexible` instead of `Expanded`, is that `Flexible` lets its child have the same or smaller width than the `Flexible` itself, while `Expanded` forces its child to have the exact same width of the `Expanded`. But both `Expanded` and `Flexible` ignore their children's width when sizing themselves.

`Flexible` 대신 `Expanded`를 사용할 때의 유일한 차이점은, `Flexible`이 자식이 `Flexible` 자신의 너비와 같거나 더 작은 너비를 가질 수 있도록 허용하는 반면, `Expanded`는 자식이 `Expanded`와 정확히 같은 너비를 가지도록 강제한다는 점입니다. 하지만 `Expanded`와 `Flexible` 모두 자식의 너비를 무시하고 자신을 크기 조정합니다.

_Note_

This means that it's impossible to expand `Row` children proportionally to their sizes. The `Row` either uses the exact child's width, or ignores it completely when you use `Expanded` or `Flexible`.

_정보_

이는 `Row`의 자식들이 자신의 크기에 비례하여 확장되는 것이 불가능함을 의미합니다. `Row`는 자식의 정확한 너비를 사용하거나, `Expanded`나 `Flexible`을 사용할 때 자식의 너비를 완전히 무시합니다.


### Example 28

![Example 28 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-28.png)

```dart
Scaffold(
  body: Container(
    color: blue,
    child: const Column(
      children: [
        Text('Hello!'),
        Text('Goodbye!'),
      ],
    ),
  ),
)
```

content_copy

The screen forces the `Scaffold` to be exactly the same size as the screen, so the `Scaffold` fills the screen. The `Scaffold` tells the `Container` that it can be any size it wants, but not bigger than the screen.

스크린은 `Scaffold`를 스크린과 정확히 동일한 크기로 강제하므로 `Scaffold`가 스크린을 채우게 됩니다. `Scaffold`는 `Container`에게 스크린보다 더 커지지 않는 한 원하는 크기로 할 수 있다고 말합니다.

_Note_

When a widget tells its child that it can be smaller than a certain size, we say the widget supplies _loose_ constraints to its child. More on that later.

_정보_

위젯이 자식에게 특정 크기보다 작을 수 있다고 말할 때, 우리는 위젯이 자식에게 _느슨한_ 제약 조건을 제공한다고 말합니다. 나중에 더 자세히 다루겠습니다.
### Example 29

![Example 29 layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-29.png)

```dart
Scaffold(
  body: SizedBox.expand(
    child: Container(
      color: blue,
      child: const Column(
        children: [
          Text('Hello!'),
          Text('Goodbye!'),
        ],
      ),
    ),
  ),
)
```

If you want the `Scaffold`'s child to be exactly the same size as the `Scaffold` itself, you can wrap its child with `SizedBox.expand`.

만약 `Scaffold`의 자식이 `Scaffold` 자신과 정확히 동일한 크기를 가지게 하고 싶다면, 자식을 `SizedBox.expand`로 감싸면 됩니다.

## Tight vs loose constraints

It's very common to hear that some constraint is "tight" or "loose", so what does that mean?

### 타이트한 제약과 느슨한 제약

제약 조건이 "타이트(tight)"하거나 "느슨한(loose)"이라고 말하는 것을 자주 듣습니다. 이 말이 무슨 뜻일까요?

### Tight constraints

A _tight_ constraint offers a single possibility, an exact size. In other words, a tight constraint has its maximum width equal to its minimum width; and has its maximum height equal to its minimum height.

An example of this is the `App` widget, which is contained by the [`RenderView`](https://api.flutter.dev/flutter/rendering/RenderView-class.html) class: the box used by the child returned by the application's [`build`](https://api.flutter.dev/flutter/widgets/State/build.html) function is given a constraint that forces it to exactly fill the application's content area (typically, the entire screen).

Another example: if you nest a bunch of boxes inside each other at the root of your application's render tree, they'll all exactly fit in each other, forced by the box's tight constraints.

If you go to Flutter's `box.dart` file and search for the `BoxConstraints` constructors, you'll find the following:

### 타이트한 제약

타이트한 제약은 하나의 가능성만을 제공합니다, 즉 정확한 크기입니다. 다시 말해, 타이트한 제약은 최대 너비가 최소 너비와 같고, 최대 높이가 최소 높이와 같습니다.

예를 들어, `App` 위젯은 `RenderView` 클래스에 의해 포함됩니다: 애플리케이션의 `build` 함수에서 반환된 자식 위젯에 사용되는 박스는 애플리케이션의 콘텐츠 영역을 정확히 채우도록 강제되는 제약을 받습니다 (일반적으로 전체 화면입니다).

또 다른 예로, 애플리케이션의 렌더 트리의 루트에 여러 박스를 중첩시킨 경우, 이들 박스는 서로 정확히 맞아들어가며, 박스의 타이트한 제약에 의해 강제됩니다.

`Flutter`의 `box.dart` 파일로 가서 `BoxConstraints` 생성자를 검색하면 다음과 같은 내용을 찾을 수 있습니다:

```dart
BoxConstraints.tight(Size size)
   : minWidth = size.width,
     maxWidth = size.width,
     minHeight = size.height,
     maxHeight = size.height;
```

If you revisit [Example 2](https://docs.flutter.dev/ui/layout/constraints#example-2), the screen forces the red `Container` to be exactly the same size as the screen. The screen achieves that, of course, by passing tight constraints to the `Container`.

만약 예제 2를 다시 살펴본다면, 화면이 빨간색 `Container`를 화면과 정확히 동일한 크기로 강제하는 것을 볼 수 있습니다. 화면은 물론, `Container`에 타이트한 제약을 전달함으로써 이를 달성합니다.
### Loose constraints

A _loose_ constraint is one that has a minimum of zero and a maximum non-zero.

Some boxes _loosen_ the incoming constraints, meaning the maximum is maintained but the minimum is removed, so the widget can have a **minimum** width and height both equal to **zero**.

Ultimately, `Center`'s purpose is to transform the tight constraints it received from its parent (the screen) to loose constraints for its child (the `Container`).

If you revisit [Example 3](https://docs.flutter.dev/ui/layout/constraints#example-3), the `Center` allows the red `Container` to be smaller, but not bigger than the screen.

### 느슨한 제약

느슨한 제약은 최소값이 0이고 최대값이 0이 아닌 제약을 말합니다.
-
일부 박스는 들어오는 제약을 느슨하게 만들어, 최대값은 유지하지만 최소값은 제거하여 위젯이 최소 너비와 높이를 모두 0으로 가질 수 있게 합니다.

결국, `Center`의 목적은 부모(화면)로부터 받은 타이트한 제약을 자식(`Container`)에게 느슨한 제약으로 변환하는 것입니다.

예제 3을 다시 살펴보면, `Center`는 빨간색 `Container`가 화면보다 작게는 허용하지만, 화면보다 크게는 허용하지 않습니다.

## Unbounded constraints

## 무한대 제약

_Note_

You might be directed here if the framework detects a problem involving box constraints. The `Flex` section below might also apply.


_정보_

만약 프레임워크가 박스 제약과 관련된 문제를 감지하면, 여기에 오도록 안내될 수 있습니다. 아래의 `Flex` 섹션도 적용될 수 있습니다.

In certain situations, a box's constraint is _unbounded_, or infinite. This means that either the maximum width or the maximum height is set to [`double.infinity`](https://api.flutter.dev/flutter/dart-core/double/infinity-constant.html).

A box that tries to be as big as possible won't function usefully when given an unbounded constraint and, in debug mode, throws an exception.

The most common case where a render box ends up with an unbounded constraint is within a flex box ([`Row`](https://api.flutter.dev/flutter/widgets/Row-class.html) or [`Column`](https://api.flutter.dev/flutter/widgets/Column-class.html)), and **within a scrollable region** (such as [`ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html) and other [`ScrollView`](https://api.flutter.dev/flutter/widgets/ScrollView-class.html) subclasses).

[`ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html), for example, tries to expand to fit the space available in its cross-direction (perhaps it's a vertically-scrolling block and tries to be as wide as its parent). If you nest a vertically scrolling [`ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html) inside a horizontally scrolling `ListView`, the inner list tries to be as wide as possible, which is infinitely wide, since the outer one is scrollable in that direction.

The next section describes the error you might encounter with unbounded constraints in a `Flex` widget.

특정 상황에서는 박스의 제약이 무한하거나 경계가 없을 수 있습니다. 이는 최대 너비나 최대 높이가 `double.infinity`로 설정된 경우를 의미합니다.

무한한 제약을 받는 박스는 가능한 한 크게 확장하려고 할 때 유용하게 작동하지 않으며, 디버그 모드에서는 예외를 발생시킵니다.

가장 일반적인 경우로는 렌더 박스가 무한한 제약을 갖는 경우가 있습니다. 이는 `Row`나 `Column` 같은 플렉스 박스 안이나 스크롤 가능한 영역(예: `ListView`와 다른 `ScrollView` 서브클래스) 안에서 발생합니다.

예를 들어, `ListView`는 교차 방향(아마도 세로 스크롤 블록에서 부모와 같은 너비를 가지려고 함)에서 사용 가능한 공간을 맞추기 위해 확장하려고 합니다. 만약 세로로 스크롤되는 `ListView`를 수평으로 스크롤되는 `ListView` 안에 중첩시키면, 내부 리스트는 무한히 넓게 되려고 합니다. 이는 외부 리스트가 해당 방향으로 스크롤 가능하기 때문입니다.

다음 섹션에서는 `Flex` 위젯에서 무한한 제약으로 인해 발생할 수 있는 오류에 대해 설명합니다.
## Flex

A flex box ([`Row`](https://api.flutter.dev/flutter/widgets/Row-class.html) and [`Column`](https://api.flutter.dev/flutter/widgets/Column-class.html)) behaves differently depending on whether its constraint is bounded or unbounded in its primary direction.

A flex box with a bounded constraint in its primary direction tries to be as big as possible.

A flex box with an unbounded constraint in its primary direction tries to fit its children in that space. Each child's `flex` value must be set to zero, meaning that you can't use [`Expanded`](https://api.flutter.dev/flutter/widgets/Expanded-class.html) when the flex box is inside another flex box or a scrollable; otherwise it throws an exception.

The _cross_ direction (width for [`Column`](https://api.flutter.dev/flutter/widgets/Column-class.html) or height for [`Row`](https://api.flutter.dev/flutter/widgets/Row-class.html)), must _never_ be unbounded, or it can't reasonably align its children.

## 플렉스

플렉스 박스(`Row`와 `Column`)는 기본 방향에서 제약이 경계가 있는지 없는지에 따라 다르게 동작합니다.

- **경계가 있는 제약**: 기본 방향에서 경계가 있는 제약을 가진 플렉스 박스는 가능한 한 크게 확장하려고 합니다.
    
- **경계가 없는 제약**: 기본 방향에서 경계가 없는 제약을 가진 플렉스 박스는 자식들을 그 공간에 맞추려고 합니다. 이 경우, 각 자식의 플렉스 값은 0으로 설정되어야 하며, 이는 플렉스 박스가 다른 플렉스 박스 안이나 스크롤 가능한 영역 안에 있을 때 `Expanded`를 사용할 수 없음을 의미합니다. 그렇지 않으면 예외가 발생합니다.
    
- **교차 방향**: 교차 방향(열의 경우 너비, 행의 경우 높이)은 결코 경계가 없어서는 안 되며, 그렇지 않으면 자식들을 적절하게 정렬할 수 없습니다.
## Learning the layout rules for specific widgets

Knowing the general layout rule is necessary, but it's not enough.

Each widget has a lot of freedom when applying the general rule, so there is no way of knowing how it behaves by just reading the widget's name.

If you try to guess, you'll probably guess wrong. You can't know exactly how a widget behaves unless you've read its documentation, or studied its source-code.

The layout source-code is usually complex, so it's probably better to just read the documentation. However, if you decide to study the layout source-code, you can easily find it by using the navigating capabilities of your IDE.

Here's an example:

- Find a `Column` in your code and navigate to its source code. To do this, use `command+B` (macOS) or `control+B` (Windows/Linux) in Android Studio or IntelliJ. You'll be taken to the `basic.dart` file. Since `Column` extends `Flex`, navigate to the `Flex` source code (also in `basic.dart`).
    
- Scroll down until you find a method called `createRenderObject()`. As you can see, this method returns a `RenderFlex`. This is the render-object for the `Column`. Now navigate to the source-code of `RenderFlex`, which takes you to the `flex.dart` file.
    
- Scroll down until you find a method called `performLayout()`. This is the method that does the layout for the `Column`.
## 특정 위젯의 레이아웃 규칙 배우기

특정 위젯의 레이아웃 규칙을 배우는 것은 중요하지만, 일반적인 레이아웃 규칙만으로는 충분하지 않습니다.

각 위젯은 일반 규칙을 적용할 때 많은 자유를 가지므로, 위젯의 이름만으로 그 동작을 알 수는 없습니다. 예측해 보려 해도 잘못될 가능성이 큽니다. 위젯이 정확히 어떻게 동작하는지 알기 위해서는 문서를 읽거나 소스 코드를 공부해야 합니다.

레이아웃 소스 코드는 일반적으로 복잡하므로 문서를 읽는 것이 더 나을 수 있습니다. 그러나 레이아웃 소스 코드를 공부하기로 결정했다면, IDE의 탐색 기능을 사용하여 쉽게 찾을 수 있습니다.

예를 들어:

- 코드에서 `Column`을 찾아 소스 코드로 이동합니다. 이를 위해 Android Studio 또는 IntelliJ에서 macOS에서는 `command+B`, Windows/Linux에서는 `control+B`를 사용합니다. 그러면 `basic.dart` 파일로 이동하게 됩니다. `Column`이 `Flex`를 확장하므로, `Flex`의 소스 코드로 이동합니다 (역시 `basic.dart`에 있습니다).
    
- 아래로 스크롤하여 `createRenderObject()`라는 메서드를 찾습니다. 이 메서드는 `RenderFlex`를 반환합니다. 이것이 `Column`의 렌더 객체입니다. 이제 `RenderFlex`의 소스 코드로 이동합니다. 이 경우, `flex.dart` 파일로 이동합니다.
    
- 아래로 스크롤하여 `performLayout()`이라는 메서드를 찾습니다. 이 메서드는 `Column`의 레이아웃을 처리하는 메서드입니다.

![A goodbye layout](https://docs.flutter.dev/assets/images/docs/ui/layout/layout-final.png)
