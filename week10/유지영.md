# Understanding constraints

## utils
```dart
const Color red = Colors.red;
const Color green = Colors.green;
const Color blue = Colors.blue;
const Color grey = Colors.grey;
const int example = 28;

const TextStyle big = TextStyle(fontSize: 40);
```
## class
```dart
class Week10Screen extends StatelessWidget {
  const Week10Screen({super.key});

  @override
  Widget build(BuildContext context) {
    final double screenWidth = MediaQuery.of(context).size.width;

    switch (example) {
      case 0:
        return example0();
      case 1:
        return example1();
      case 2:
        return example2();
      case 3:
        return example3(screenWidth);
      case 4:
        return example4();
      case 5:
        return example5();
      case 6:
        return example6();
      case 7:
        return example7();
      case 8:
        return example8();
      case 9:
        return example9();
      case 10:
        return example10();
      case 11:
        return example11();
      case 12:
        return example12();
      case 13:
        return example13();
      case 14:
        return example14();
      case 15:
        return example15();
      case 16:
        return example16();
      case 17:
        return example17();
      case 18:
        return example18();
      case 19:
        return example19();
      case 20:
        return example20();
      case 21:
        return example21();
      case 22:
        return example22();
      case 23:
        return example23();
      case 24:
        return example24();
      case 25:
        return example25();
      case 26:
        return example26();
      case 27:
        return example27();
      case 28:
        return example28();
      case 29:
        return example29();
      default:
        return Container();
    }
  }
}
```
## widget (example code 1 ~ 29)

### **Example 1[#](https://docs.flutter.dev/ui/layout/constraints#example-1)**
<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-1.png"/>

**The screen is the parent of the `Container`, and it forces the `Container` to be exactly the same size as the screen.**

스크린이 Container의 부모이며, 스크린은 Container가 스크린과 정확히 같은 크기가 되도록 강제합니다.

**So the `Container` fills the screen and paints it red.**

따라서 Container는 스크린을 채우고 빨갛게 칠합니다.

```dart
Widget example1() {
  // 스크린이 컨테이너의 부모
  /// 스크린은 자식이 자신과 같은 크기가 되도록 강제
  /// Scaffold 위젯을 사용하면, 자식 위젯들은 Scaffold의 전체 크기를 채우려고 한다
  /// Scaffold 내부의 body에 들어가는 위젯은 Scaffold의 크기(즉, 화면 크기)만큼 확장된다

  // 다른 레이아웃 위젯
  /// Column 또는 Row: 자식 위젯들은 메인 방향(수직 또는 수평)으로만 크기를 제한받고, 반대 방향으로는 가능한 최대 크기를 차지
  /// Expanded와 Flexible: 이 위젯들은 부모 위젯 내에서 자식 위젯이 가능한 최대 크기를 차지하도록 할 때 사용
  /// ConstrainedBox와 SizedBox: 자식의 크기를 명시적으로 제한하거나 고정된 크기를 강제

  return Container(color: red);
}
```

### **Example 2[#](https://docs.flutter.dev/ui/layout/constraints#example-2)**

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-2.png"/>

**The red `Container` wants to be 100 × 100, but it can't, because the screen forces it to be exactly the same size as the screen.**

빨간색 Container는 100 × 100이 되기를 원하지만, 스크린이 그것을 강제로 스크린과 동일한 크기로 만듭니다. 

**So the `Container` fills the screen.**

따라서 Container는 스크린을 채웁니다.

```dart
Widget example2() {
  // 화면이 이 Container의 크기를 강제로 자신과 동일하게 만드는 상황
  /// Flutter에서는 부모 위젯이 자식 위젯에 대해 얼마나 커질 수 있는지를 지정할 수 있다.
  /// 예를 들어, Scaffold나 Screen 같은 상위 레이아웃 위젯은 자식이 자신과 동일한 크기를 가지도록 요구할 수 있다.
  /// Container는 자식의 크기 또는 부모의 제약 조건에 맞추어 크기가 결정
  /// 부모 위젯이 Container에게 전체 화면을 채우도록 강제하는 경우, Container는 지정된 크기 대신 부모의 크기를 따르게 된다.
  return Container(width: 100, height: 100, color: red);
}
```
### **Example 3[#](https://docs.flutter.dev/ui/layout/constraints#example-3)**

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-3.png"/>

**The screen forces the `Center` to be exactly the same size as the screen, so the `Center` fills the screen.**

스크린은 Center가 스크린과 정확히 같은 크기가 되도록 강제하므로 Center는 스크린을 채웁니다.

**The `Center` tells the `Container` that it can be any size it wants, but not bigger than the screen. Now the `Container` can indeed be 100 × 100.**

Center는 Container에게 스크린보다 크지 않는 한 원하는 크기가 될 수 있다고 알려줍니다. 이제 Container는 100 × 100이 될 수 있습니다.

```dart
Widget example3(double screenWidth) {
  // Center
  ///	Center 위젯은 부모 위젯으로부터 전체 화면을 차지하도록 강제, Center는 항상 화면 전체를 채운다.
  /// Center는 자식 위젯에게 자신의 크기 내에서 자유롭게 크기를 결정할 수 있도록 허용
  /// 단, 자식 위젯이 Center의 크기(즉, 화면 크기)를 초과할 수는 없음
  ///
  /// [Q] Center 사용 시 screen보다 크기가 넓을 시 overflow 가 발생하지 않는가? => yes
  return Center(
    child: Container(width: 100, height: 100, color: red),
    // child: Container(width: screenWidth * 100, height: screenWidth * 100, color: red),
  );
}
```
### **Example 4**[#](https://docs.flutter.dev/ui/layout/constraints#example-4)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-4.png"/>

**This is different from the previous example in that it uses `Align` instead of `Center`.**

이전 예제와 다른 점은 Center 대신 Align을 사용한 것입니다. 

**`Align` also tells the `Container` that it can be any size it wants, but if there is empty space it won't center the `Container`. Instead, it aligns the container to the bottom-right of the available space.**

Align도 Container에게 원하는 크기를 가질 수 있다고 알려주지만, 비어 있는 공간이 있을 때 Container를 중앙에 배치하지 않고, 대신 Container를 오른쪽 하단에 맞춥니다.

```dart
Widget example4() {
  // Align
  /// Align은 자식 위젯인 Container가 스스로의 크기를 결정할 수 있도록 허용
  /// 하지만, 자식 위젯이 차지하지 않는 여유 공간이 있을 때 위치를 중앙이 아닌 alignment 속성을 통해 자식 위젯의 위치를 결정
  return Align(
    alignment: Alignment.bottomRight,
    child: Container(width: 100, height: 100, color: red),
  );
}
```
### **Example 5**[#](https://docs.flutter.dev/ui/layout/constraints#example-5)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-5.png"/>

**The screen forces the `Center` to be exactly the same size as the screen, so the `Center` fills the screen.**

스크린은 Center가 스크린과 정확히 같은 크기가 되도록 강제하므로 Center는 스크린을 채웁니다. 

**The `Center` tells the `Container` that it can be any size it wants, but not bigger than the screen. The `Container` wants to be of infinite size, but since it can't be bigger than the screen, it just fills the screen.**

Center는 Container에게 스크린보다 크지 않는 한 원하는 크기가 될 수 있다고 알려줍니다. Container는 무한한 크기를 원하지만, 스크린보다 클 수 없으므로 스크린을 채웁니다.

```dart
Widget example5() {
  /// 스크린은 Center가 자신과 같은 크기가 되도록 강제, Center는 스크린을 채움
  /// Center의 자식인 Container는 스크린보다 크지 않는 한 원하는 크기가 될 수 있음
  /// Container는 무한한 크기를 원하지만, 스크린보다 클 수 없으므로 스크린을 채움
  return Container(width: double.infinity, height: double.infinity, color: red);
}
```

### **Example 6**[#](https://docs.flutter.dev/ui/layout/constraints#example-6)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-6.png"/>

**The screen forces the `Center` to be exactly the same size as the screen, so the `Center` fills the screen.**

스크린은 Center가 스크린과 정확히 같은 크기가 되도록 강제하므로 Center는 스크린을 채웁니다. 

**The `Center` tells the `Container` that it can be any size it wants, but not bigger than the screen. Since the `Container` has no child and no fixed size, it decides it wants to be as big as possible, so it fills the whole screen.**

Center는 Container에게 스크린보다 크지 않는 한 원하는 크기를 가질 수 있다고 알려줍니다. Container에는 자식도 고정 크기도 없으므로 가능한 한 크게 되고, 스크린 전체를 채웁니다. 

**But why does the `Container` decide that? Simply because that's a design decision by those who created the `Container` widget. It could have been created differently, and you have to read the [`Container`](https://api.flutter.dev/flutter/widgets/Container-class.html) API documentation to understand how it behaves, depending on the circumstances.**

왜 Container가 그렇게 결정하는지 궁금할 수 있습니다. 그것은 Container 위젯을 만든 사람들이 디자인 결정으로 그렇게 만든 것입니다. 이와 다르게 만들어질 수도 있었고, Container API 문서를 읽어야 그 동작을 이해할 수 있습니다.

```dart
Widget example6() {
  /// Center 위젯은 자식 위젯에게 자신보다 크지 않는 한 원하는 크기를 가질 수 있도록 허용
  /// Container는 자식 위젯이나 고정된 크기가 없기 때문에 가능한 한 가장 큰 크기를 선택
  return Center(
    child: Container(color: red),
  );
}
```

### **Example 7**[#](https://docs.flutter.dev/ui/layout/constraints#example-7)
<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-7.png"/>

**The screen forces the `Center` to be exactly the same size as the screen, so the `Center` fills the screen.**

스크린은 Center가 스크린과 정확히 같은 크기가 되도록 강제하므로 Center는 스크린을 채웁니다.

**The `Center` tells the red `Container` that it can be any size it wants, but not bigger than the screen. Since the red `Container` has no size but has a child, it decides it wants to be the same size as its child.**

**The red `Container` tells its child that it can be any size it wants, but not bigger than the screen.**

Center는 빨간 Container에게 스크린보다 크지 않는 한 원하는 크기가 될 수 있다고 알려줍니다. 빨간 Container에는 크기가 없지만 자식이 있으므로 자식 크기만큼 크기를 결정합니다. 

**The child is a green `Container` that wants to be 30 × 30. Given that the red `Container` sizes itself to the size of its child, it is also 30 × 30. The red color isn't visible because the green `Container` entirely covers the red `Container`.**

빨간 Container는 자식에게 스크린보다 크지 않는 한 원하는 크기를 가질 수 있다고 알려줍니다. 자식은 30 × 30 크기의 초록색 Container입니다. 빨간 Container는 자식 크기만큼 크기를 결정하므로 역시 30 × 30이 됩니다. 초록색 Container가 빨간 Container를 완전히 덮어서 빨간색은 보이지 않습니다.

```dart
Widget example7() {
  // Center
  /// 위젯은 스크린 크기, 자식 위젯을 가운데로 배치, 자식이 가능한 크기를 가지도록 허용

  // 첫 번째 Container (빨간색) :
  /// 색상만 지정되어 있고, 자식 위젯이 있으므로, 자식의 크기에 맞게 크기를 결정
  /// 따라서, 첫 번째 Container는 자식인 초록색 Container의 크기(30 × 30)에 맞춰짐

  // 두 번째 Container (초록색) :
  /// 크기(30 × 30)가 명시되어 있으므로, 해당 크기를 유지
  return Center(
    child: Container(
      color: red,
      child: Container(color: green, width: 30, height: 30),
    ),
  );
}
```

### **Example 8**[#](https://docs.flutter.dev/ui/layout/constraints#example-8)
<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-8.png"/>


**The red `Container` sizes itself to its children's size, but it takes its own padding into consideration. So it is also 30 × 30 plus padding. The red color is visible because of the padding, and the green `Container` has the same size as in the previous example.**

빨간 Container는 자식의 크기에 맞추지만, 자신의 패딩을 고려합니다. 따라서 자식의 크기와 패딩을 더한 크기로 결정됩니다. 패딩 덕분에 빨간색이 보이고, 초록색 Container는 이전 예제와 동일한 크기를 가집니다.

```dart
Widget example8() {
  // Center
  /// 위젯은 스크린 크기, 자식 위젯을 가운데로 배치, 자식이 가능한 크기를 가지도록 허용

  // 첫 번째 Container (빨간색) :
  ///	padding: const EdgeInsets.all(20)로 설정 -> 내부의 자식 위젯과의 거리가 20
  ///	크기는 자식 Container의 크기 + 패딩을 포함한 크기로 결정
  ///	자식 Container의 크기는 30x30, 패딩이 모든 방향으로 20 픽셀 -> 빨간색 Container의 최종 크기는 30 + 20 * 2 = 70 × 70

  // 두 번째 Container (초록색):
  /// 30x30 크기를 가지며, 빨간색 Container의 중앙에 배치
  ///	패딩에 의해 초록색 Container는 빨간색 Container 내부에서 20 픽셀의 여유 공간을 가짐
  return Center(
    child: Container(
      padding: const EdgeInsets.all(20),
      color: red,
      child: Container(color: green, width: 30, height: 30),
    ),
  );
}
```

### **Example 9[#](https://docs.flutter.dev/ui/layout/constraints#example-9)**
<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-9.png"/>

**You might guess that the `Container` has to be between 70 and 150 pixels, but you would be wrong. The `ConstrainedBox` only imposes additional constraints from those it receives from its parent.**

Container는 70에서 150 픽셀 사이의 크기를 가질 것으로 예상할 수 있지만, 그렇지 않습니다. ConstrainedBox는 부모로부터 받은 제약에 추가 제약을 부과합니다. 

**Here, the screen forces the `ConstrainedBox` to be exactly the same size as the screen, so it tells its child `Container` to also assume the size of the screen, thus ignoring its `constraints` parameter.**

이 경우, 스크린이 ConstrainedBox를 스크린과 정확히 같은 크기로 강제하므로, 자식 Container도 스크린 크기를 가지게 되어 제약 매개변수가 무시됩니다.

```dart
Widget example9() {
  // ConstrainedBox
  /// 자식 위젯에게 특정 크기 제한을 적용하는 위젯, 이 제약 조건은 부모로부터 받은 제약 조건에 더해져 적용
  /// 그러나 부모의 제약 조건이 더 강할 경우, 자식에게 전달되는 추가 제약 조건이 무시

  /// 화면은 ConstrainedBox에 대해 전체 화면 크기와 동일한 크기를 강제
  ///	constraints : 최소 크기(minWidth, minHeight)와 최대 크기(maxWidth, maxHeight)가 설정되어 있음

  /// Container는 10x10으로 설정되었지만 화면 크기로 확장, ConstrainedBox의 제약 조건은 무시
  return ConstrainedBox(
    constraints: const BoxConstraints(
      minWidth: 70,
      minHeight: 70,
      maxWidth: 150,
      maxHeight: 150,
    ),
    child: Container(color: red, width: 10, height: 10),
  );
}
```

### **Example 10**[#](https://docs.flutter.dev/ui/layout/constraints#example-10)
<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-10.png"/>

**Now, `Center` allows `ConstrainedBox` to be any size up to the screen size. The `ConstrainedBox` imposes additional constraints from its `constraints` parameter onto its child.**

이제 Center가 ConstrainedBox가 스크린 크기까지 가질 수 있도록 허용합니다. ConstrainedBox는 자신의 제약 매개변수로부터 자식에게 추가 제약을 부과합니다. 

**The Container must be between 70 and 150 pixels. It wants to have 10 pixels, so it ends up having 70 (the minimum).**

Container는 70에서 150 픽셀 사이의 크기를 가져야 합니다. Container는 10픽셀을 원하지만, 최소 크기인 70픽셀이 됩니다.

```dart
Widget example10() {
  //  Center
  /// Center 위젯은 부모로부터 전체 화면 크기를 강제, 자식 위젯을 화면의 중앙에 배치
  /// 이 경우, ConstrainedBox가 Center의 자식이므로, 화면의 중앙에 위치하게 됩니다.

  //  ConstrainedBox
  /// ConstrainedBox는 자식에게 특정 제약 조건을 추가
  /// 이 예제에서는 최소 크기(70x70)와 최대 크기(150x150)가 설정

  // 	자식 Container
  /// 10x10 크기로 설정되어 있지만, ConstrainedBox의 제약 조건에 따라 최소 크기 70x70을 강제
  /// 원래 크기(10x10) 대신, ConstrainedBox의 최소 크기인 70x70으로 확장
  return Center(
    child: ConstrainedBox(
      constraints: const BoxConstraints(
        minWidth: 70,
        minHeight: 70,
        maxWidth: 150,
        maxHeight: 150,
      ),
      child: Container(color: red, width: 10, height: 10),
    ),
  );
}
```
### **Example 11**[#](https://docs.flutter.dev/ui/layout/constraints#example-11)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-11.png"/>

```dart
Center(  child: ConstrainedBox(    constraints: const BoxConstraints(      minWidth: 70,      minHeight: 70,      maxWidth: 150,      maxHeight: 150,    ),    child: Container(color: red, width: 1000, height: 1000),  ),)
```

**`Center` allows `ConstrainedBox` to be any size up to the screen size. The `ConstrainedBox` imposes additional constraints from its `constraints` parameter onto its child.**

Center는 ConstrainedBox가 스크린 크기까지 가질 수 있도록 허용합니다. ConstrainedBox는 자신의 제약 매개변수로부터 자식에게 추가 제약을 부과합니다. 

**The `Container` must be between 70 and 150 pixels. It wants to have 1000 pixels, so it ends up having 150 (the maximum).**

Container는 70에서 150 픽셀 사이의 크기를 가져야 합니다. Container는 1000픽셀을 원하지만, 최대 크기인 150픽셀이 됩니다.

```dart
Widget example11() {
  //  Center
  /// Center 위젯은 화면 전체 크기를 차지, 자식 위젯은 그 안에서 자유롭게 크기를 가질 수 있음.

  //  ConstrainedBox
  /// 자식 위젯에게 최소 및 최대 크기 제한
  /// 부모인 Center로부터 크기 제한 + 자신의 제약 조건(BoxConstraints)을 자식 위젯인 Container에게 부여

  //  Container
  /// 1000x1000 크기로 설정되어 있지만, ConstrainedBox의 제약에 따라 최소 70x70, 최대 150x150 크기 사이로 크기가 조정
  /// 1000x1000 크기를 가지려고 하지만, 최대 허용 크기인 150x150으로 제한
  return Center(
    child: ConstrainedBox(
      constraints: const BoxConstraints(
        minWidth: 70,
        minHeight: 70,
        maxWidth: 150,
        maxHeight: 150,
      ),
      child: Container(color: red, width: 1000, height: 1000),
    ),
  );
}
```

### **Example 12**[#](https://docs.flutter.dev/ui/layout/constraints#example-12)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-12.png"/>

**`Center` allows `ConstrainedBox` to be any size up to the screen size. The `ConstrainedBox` imposes additional constraints from its `constraints` parameter onto its child.**

Center는 ConstrainedBox가 스크린 크기까지 가질 수 있도록 허용합니다. ConstrainedBox는 자신의 제약 매개변수로부터 자식에게 추가 제약을 부과합니다. 

**The `Container` must be between 70 and 150 pixels. It wants to have 100 pixels, and that's the size it has, since that's between 70 and 150.**

Container는 70에서 150 픽셀 사이의 크기를 가져야 합니다. Container는 100픽셀을 원하며, 70에서 150 사이이므로 그 크기를 가집니다.

```dart
Widget example12() {
  //	Center
  /// Center 위젯은 화면 전체 크기를 차지, 자식 위젯은 그 안에서 자유롭게 크기를 가질 수 있음.

  //	ConstrainedBox
  /// 자식 위젯에게 최소 및 최대 크기 제한

  //	Container
  /// 100x100 크기 -> ConstrainedBox의 제약 조건 내에서 100x100 크기는 허용되는 범위(70x70에서 150x150) 내에 있음
  /// 설정된 크기인 100x100을 유지
  return Center(
    child: ConstrainedBox(
      constraints: const BoxConstraints(
        minWidth: 70,
        minHeight: 70,
        maxWidth: 150,
        maxHeight: 150,
      ),
      child: Container(color: red, width: 100, height: 100),
    ),
  );
}
```
### **Example 13**[#](https://docs.flutter.dev/ui/layout/constraints#example-13)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-13.png"/>

**The screen forces the `UnconstrainedBox` to be exactly the same size as the screen. However, the `UnconstrainedBox` lets its child `Container` be any size it wants.**

스크린은 UnconstrainedBox를 스크린과 정확히 같은 크기로 강제하지만, UnconstrainedBox는 자식 Container가 원하는 크기를 가질 수 있도록 합니다.

```dart
Widget example13() {
  //  UnconstrainedBox
  /// 부모(화면)는 UnconstrainedBox가 전체 화면 크기를 가지도록 강제
  /// UnconstrainedBox는 부모로부터 받은 크기 제약을 자식에게 전달하지 않음
  /// 즉, 자식이 자신의 크기를 유지할 수 있도록 함

  // 	Container
  /// 20x50 크기로 설정
  /// UnconstrainedBox에 의해 이 크기가 유지, 화면의 중앙에 배치
  return UnconstrainedBox(
    child: Container(color: red, width: 20, height: 50),
  );
}
```
### **Example 14[#](https://docs.flutter.dev/ui/layout/constraints#example-14)**

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-14.png"/>

```dart
UnconstrainedBox(  child: Container(color: red, width: 4000, height: 50),)
```

**The screen forces the `UnconstrainedBox` to be exactly the same size as the screen, and `UnconstrainedBox` lets its child `Container` be any size it wants.**

스크린은 UnconstrainedBox를 스크린과 정확히 같은 크기로 강제하지만, UnconstrainedBox는 자식 Container가 원하는 크기를 가질 수 있도록 합니다. 

**Unfortunately, in this case the `Container` is 4000 pixels wide and is too big to fit in the `UnconstrainedBox`, so the `UnconstrainedBox` displays the much dreaded "overflow warning".**

그러나 이 경우 Container는 4000픽셀 너비로 너무 커서 UnconstrainedBox에 맞지 않아 “오버플로 경고”가 표시됩니다.

```dart
Widget example14() {
  //  UnconstrainedBox
  /// 부모(화면)는 UnconstrainedBox가 전체 화면 크기를 가지도록 강제
  /// UnconstrainedBox는 부모로부터 받은 크기 제약을 자식에게 전달하지 않음
  /// 즉, 자식이 자신의 크기를 유지할 수 있도록 함

  //	Container
  /// 4000x50 크기로 설정
  /// 이 크기는 화면의 가로 너비를 초과, UnconstrainedBox 내부에서 Container가 화면에 완전히 표시될 수 없음.

  //	overflow
  /// Container의 너비 화면 너비를 초과
  /// Flutter는 이 초과 부분을 표시할 수 없으므로, “오버플로 경고”가 발생
  return UnconstrainedBox(
    child: Container(color: red, width: 4000, height: 50),
  );
}
```

### **Example 15**[#](https://docs.flutter.dev/ui/layout/constraints#example-15)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-15.png"/>

**The screen forces the `OverflowBox` to be exactly the same size as the screen, and `OverflowBox` lets its child `Container` be any size it wants.**

스크린은 OverflowBox를 스크린과 정확히 같은 크기로 강제하고, OverflowBox는 자식 Container가 원하는 크기를 가질 수 있도록 합니다. 

**`OverflowBox` is similar to `UnconstrainedBox`; the difference is that it won't display any warnings if the child doesn't fit the space.**

OverflowBox는 UnconstrainedBox와 유사하지만, 자식이 공간에 맞지 않으면 경고를 표시하지 않습니다. 

**In this case, the `Container` has 4000 pixels of width, and is too big to fit in the `OverflowBox`, but the `OverflowBox` simply shows as much as it can, with no warnings given.**

이 경우 Container는 4000픽셀 너비로 너무 커서 OverflowBox에 맞지 않지만, OverflowBox는 가능한 만큼만 표시하고 경고를 표시하지 않습니다.

```dart
Widget example15() {
  //  OverflowBox
  /// OverflowBox는 UnconstrainedBox와 비슷한 기능을 하지만, 자식 위젯이 부모의 경계를 넘어설 때 경고 없이 작동
  /// OverflowBox는 부모로부터 받은 크기 제한을 자식에게 전달하지 않으며, 자식이 지정된 크기보다 크게 확장되더라도 이를 허용

  //	Container
  /// 4000x50 크기로 설정, OverflowBox 덕분에 이 크기를 유지할 수 있음

  //	no overflow
  /// OverflowBox는 자식이 부모의 크기를 초과할 때 경고를 표시하지 않음
  ///	화면에 표시되지 않는 부분이 있더라도, OverflowBox는 경고 없이 가능한 만큼의 내용을 표시
  return OverflowBox(
    minWidth: 0,
    minHeight: 0,
    maxWidth: double.infinity,
    maxHeight: double.infinity,
    child: Container(color: red, width: 4000, height: 50),
  );
}
```

### **Example 16[#](https://docs.flutter.dev/ui/layout/constraints#example-16)**

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-16.png"/>

**This won't render anything, and you'll see an error in the console. The `UnconstrainedBox` lets its child be any size it wants, however its child is a `Container` with infinite size.**

UnconstrainedBox는 자식 Container가 원하는 크기를 가질 수 있도록 합니다. 그러나 자식 Container는 무한한 크기를 가지고 있습니다. 

**Flutter can't render infinite sizes, so it throws an error with the following message: `BoxConstraints forces an infinite width.`**

Flutter는 무한한 크기를 렌더링할 수 없으므로 다음 메시지와 함께 오류를 표시합니다: “BoxConstraints가 무한 너비를 강제합니다.”

```dart
Widget example16() {
  //  UnconstrainedBox
  /// 부모(화면)는 UnconstrainedBox가 전체 화면 크기를 가지도록 강제
  /// UnconstrainedBox는 부모로부터 받은 크기 제약을 자식에게 전달하지 않음
  /// 그러나, 16번에서는 자식 Container가 width: double.infinity로 설정되어 있어 무한한 크기를 가짐

  //	Container:
  /// 자식 Container가 무한한 너비를 가지려는 경우, Flutter는 이를 처리할 수 없음

  //	hasSize
  /// Flutter는 무한한 크기를 렌더링할 수 없으므로, hasSize와 오류 발생
  /// UnconstrainedBox가 자식에게 무한한 크기를 허용하려고 하지만, Flutter의 레이아웃 시스템에서 무한 크기가 불가능하다는 점에서 발생
  return UnconstrainedBox(
    child: Container(color: Colors.red, width: double.infinity, height: 100),
  );
}
```

### **Example 17**[#](https://docs.flutter.dev/ui/layout/constraints#example-17)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-17.png"/>

**Here you won't get an error anymore, because when the `LimitedBox` is given an infinite size by the `UnconstrainedBox`; it passes a maximum width of 100 down to its child.**

여기서는 더 이상 오류가 발생하지 않습니다. LimitedBox가 UnconstrainedBox로부터 무한한 크기를 받으면, 자식에게 최대 100픽셀의 너비를 전달하기 때문입니다. 

**If you swap the `UnconstrainedBox` for a `Center` widget, the `LimitedBox` won't apply its limit anymore (since its limit is only applied when it gets infinite constraints), and the width of the `Container` is allowed to grow past 100.**

UnconstrainedBox를 Center로 바꾸면 LimitedBox는 더 이상 제한을 적용하지 않고, Container의 너비가 100픽셀을 초과할 수 있습니다. 

**This explains the difference between a `LimitedBox` and a `ConstrainedBox`.**

이는 LimitedBox와 ConstrainedBox의 차이점을 설명합니다.

```dart
Widget example17() {
  //  UnconstrainedBox
  /// 부모(화면)는 UnconstrainedBox가 전체 화면 크기를 가지도록 강제
  /// UnconstrainedBox는 부모로부터 받은 크기 제약을 자식에게 전달하지 않음
  /// 즉, 자식이 자신의 크기를 유지할 수 있도록 함

  //	LimitedBox
  ///	LimitedBox는 부모로부터 무한한 크기 제약을 받으면, 자신의 자식에게 최대 크기를 제한하는 역할
  ///	자식 Container에게 최대 100픽셀 너비를 전달

  //	Container
  ///	width: double.infinity로 설정되어 있지만, LimitedBox에 의해 너비가 100픽셀로 제한
  ///	Container는 무한한 너비를 가지려 했지만, LimitedBox에 의해 100픽셀로 제한
  return UnconstrainedBox(
    child: LimitedBox(
      maxWidth: 100,
      child: Container(
        color: Colors.red,
        width: double.infinity,
        height: 100,
      ),
    ),
  );
}
```

### **Example 18**[#](https://docs.flutter.dev/ui/layout/constraints#example-18)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-18.png"/>

**The screen forces the `FittedBox` to be exactly the same size as the screen. The `Text` has some natural width (also called its intrinsic width) that depends on the amount of text, its font size, and so on.**

화면은 `FittedBox`가 화면과 정확히 동일한 크기를 가지도록 강제합니다. `Text`는 텍스트의 양, 글꼴 크기 등에 따라 자연적인 너비(고유 너비)를 가집니다.

**The `FittedBox` lets the `Text` be any size it wants, but after the `Text` tells its size to the `FittedBox`, the `FittedBox` scales the Text until it fills all of the available width.**

`FittedBox`는 `Text`가 원하는 크기를 가지도록 허용하지만, `Text`가 자신의 크기를 `FittedBox`에 전달한 후에는 `FittedBox`가 텍스트를 가용한 너비를 가득 채울 때까지 크기를 조정합니다.

```dart
Widget example18() {
  // const
  /// 위젯을 불변(immutable)로 만들어 런타임에 다시 빌드하지 않음

  // FittedBox
  /// 자식 위젯의 크기를 부모 위젯의 크기에 맞추어 조정
  /// 자식 위젯의 크기가 부모 위젯보다 작거나 클 경우, FittedBox는 자식 위젯을 부모 위젯의 크기에 맞춤
  return const FittedBox(
    child: Text('Some Example Text.'),
  );
}
```

### **Example 19**[#](https://docs.flutter.dev/ui/layout/constraints#example-19)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-19.png"/>

**But what happens if you put the `FittedBox` inside of a `Center` widget? The `Center` lets the `FittedBox` be any size it wants, up to the screen size.**

FittedBox를 Center 위젯 안에 넣으면 어떻게 될까요? Center는 FittedBox가 화면 크기까지 원하는 크기를 가질 수 있도록 허용합니다.

**The `FittedBox` then sizes itself to the `Text`, and lets the `Text` be any size it wants. Since both `FittedBox` and the `Text` have the same size, no scaling happens.**

FittedBox는 그 다음에 자신을 Text의 크기에 맞추고, Text도 원하는 크기를 가질 수 있도록 허용합니다. FittedBox와 Text가 동일한 크기를 가지므로, 아무런 스케일링도 발생하지 않습니다.

```dart
Widget example19() {
  // const
  /// 위젯을 불변(immutable)로 만들어 런타임에 다시 빌드하지 않음

  //	Center
  /// Center 위젯은 화면(부모) 전체 크기를 차지, 자식 위젯은 그 안에서 자유롭게 크기를 가질 수 있음.

  // FittedBox
  /// 자식 위젯의 크기를 부모 위젯의 크기에 맞추어 조정
  /// 자식 위젯의 크기가 부모 위젯보다 작거나 클 경우, FittedBox는 자식 위젯을 부모 위젯의 크기에 맞춤
  /// 여기서는 Center가 자식 위젯에게 원하는 크기를 가지도록 허용하므로, FittedBox는 자식 위젯인 Text에 맞게 크기를 조정
  return const Center(
    child: FittedBox(
      child: Text('Some Example Text.'),
    ),
  );
}
```

### **Example 20**[#](https://docs.flutter.dev/ui/layout/constraints#example-20)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-20.png"/>

**However, what happens if `FittedBox` is inside of a `Center` widget, but the `Text` is too large to fit the screen?**

그러나 `FittedBox`가 `Center` 위젯 안에 있고, `Text`가 화면에 맞지 않을 정도로 너무 크다면 어떻게 될까요?

**`FittedBox` tries to size itself to the `Text`, but it can't be bigger than the screen. It then assumes the screen size, and resizes `Text` so that it fits the screen, too.**

`FittedBox`는 자신을 `Text`에 맞추려고 하지만, 화면보다 커질 수는 없습니다. 따라서 `FittedBox`는 화면 크기를 가지게 되고, `Text`도 화면에 맞도록 크기를 조정하게 됩니다.

```dart
Widget example20() {
  // const
  /// 위젯을 불변(immutable)로 만들어 런타임에 다시 빌드하지 않음

  //	Center
  /// Center 위젯은 화면(부모) 전체 크기를 차지, 자식 위젯은 그 안에서 자유롭게 크기를 가질 수 있음.

  // FittedBox
  /// 자식 위젯의 크기를 부모 위젯의 크기에 맞추어 조정
  /// 자식 위젯의 크기가 부모 위젯보다 작거나 클 경우, FittedBox는 자식 위젯을 부모 위젯의 크기에 맞춤
  /// 여기서는 전체 텍스트가 화면에 맞춰지도록 텍스트의 크기를 축소함
  return const Center(
    child: FittedBox(
      child: Text(
          'This is some very very very large text that is too big to fit a regular screen in a single line.'),
    ),
  );
}
```

### **Example 21**[#](https://docs.flutter.dev/ui/layout/constraints#example-21)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-21.png"/>

**If, however, you remove the `FittedBox`, the `Text` gets its maximum width from the screen, and breaks the line so that it fits the screen.**

그러나 `FittedBox`를 제거하면, `Text`는 화면에서 최대 너비를 가져와 화면에 맞도록 줄을 나눕니다.

```dart
Widget example21() {
  //	Center
  /// Center 위젯은 화면(부모) 전체 크기를 차지, 자식 위젯은 그 안에서 자유롭게 크기를 가질 수 있음.

  // Text
  /// 길이가 화면 너비를 초과할 경우 줄이 나뉘어 여러 줄에 걸쳐 표시
  return const Center(
    child: Text(
        'This is some very very very large text that is too big to fit a regular screen in a single line.'),
  );
}
```

### **Example 22**[#](https://docs.flutter.dev/ui/layout/constraints#example-22)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-22.png"/>

**`FittedBox` can only scale a widget that is bounded (has non-infinite width and height). Otherwise, it won't render anything, and you'll see an error in the console.**

`FittedBox`는 경계가 있는(즉, 무한하지 않은 너비와 높이를 가진) 위젯만 스케일링할 수 있습니다. 그렇지 않으면 아무것도 렌더링하지 않으며, 콘솔에 오류가 표시됩니다.

```dart
Widget example22() {
  // FittedBox
  /// 자식 위젯의 크기를 부모 위젯의 크기에 맞추어 조정
  /// 자식 위젯의 크기가 부모 위젯보다 작거나 클 경우, FittedBox는 자식 위젯을 부모 위젯의 크기에 맞춤
  /// 스케일링이 적용되려면 자식 위젯이 고정된 크기(즉, 제한된 크기)를 가져야 함

  /// 이 예제에서는 컨테이너는 무한한 너비를 가지려고 하기 때문에 렌더링이 되지 않음
  return FittedBox(
    child: Container(
      height: 20,
      width: double.infinity,
      color: Colors.red,
    ),
  );
}
```

### **Example 23**[#](https://docs.flutter.dev/ui/layout/constraints#example-23)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-23.png"/>

**The screen forces the `Row` to be exactly the same size as the screen.**

화면은 `Row`를 화면과 정확히 동일한 크기로 만듭니다.

**Just like an `UnconstrainedBox`, the `Row` won't impose any constraints onto its children, and instead lets them be any size they want. The `Row` then puts them side-by-side, and any extra space remains empty.**

`UnconstrainedBox`와 마찬가지로, `Row`는 자식 위젯에게 아무런 제약도 가하지 않고, 원하는 크기를 가지도록 허용합니다. 그런 다음 `Row`는 자식 위젯들을 나란히 배치하며, 남은 공간은 비워둡니다.

```dart
Widget example23() {
  // Row
  /// 자식 위젯들을 수평으로 나란히 배치, 부모 위젯의 크기
  /// 자식 위젯들은 제약 없이 각각의 크기에 맞게 그려짐
  return Row(
    children: [
      Container(color: red, child: const Text('Hello!', style: big)),
      Container(color: green, child: const Text('Goodbye!', style: big)),
    ],
  );
}
```

### **Example 24**[#](https://docs.flutter.dev/ui/layout/constraints#example-24)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-24.png"/>

**Since `Row` won't impose any constraints onto its children, it's quite possible that the children might be too big to fit the available width of the `Row`. In this case, just like an `UnconstrainedBox`, the `Row` displays the "overflow warning".**

Row는 자식 위젯에게 아무런 제약을 가하지 않기 때문에, 자식 위젯들이 Row의 가용 너비에 맞지 않을 정도로 너무 클 수 있습니다. 이 경우 UnconstrainedBox와 마찬가지로, Row는 “오버플로우 경고”를 표시합니다.

```dart
Widget example24() {
  // Row
  /// 자식 위젯들을 수평으로 나란히 배치, 부모 위젯의 크기
  /// 자식 위젯들은 제약 없이 각각의 크기에 맞게 그려짐

  // overFlow
  /// 이 예제에서는 Row가 자식에게 크기 제약을 주지 않아 부모(화면) 크기보다 커 overFlow 에러남
  return Row(
    children: [
      Container(
        color: red,
        child: const Text(
          'This is a very long text that ' 'won\'t fit the line.',
          style: big,
        ),
      ),
      Container(color: green, child: const Text('Goodbye!', style: big)),
    ],
  );
}
```

### **Example 25**[#](https://docs.flutter.dev/ui/layout/constraints#example-25)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-25.png"/>

**When a `Row`'s child is wrapped in an `Expanded` widget, the `Row` won't let this child define its own width anymore.**

`Row`의 자식이 `Expanded` 위젯으로 감싸지면, `Row`는 더 이상 이 자식이 자신의 너비를 정의하도록 허용하지 않습니다.

**Instead, it defines the `Expanded` width according to the other children, and only then the `Expanded` widget forces the original child to have the `Expanded`'s width.**

대신, `Row`는 다른 자식들에 따라 `Expanded`의 너비를 정의하고, 그 후에 `Expanded` 위젯이 원래 자식을 `Expanded`의 너비로 강제합니다.

**In other words, once you use `Expanded`, the original child's width becomes irrelevant, and is ignored.**

다시 말해, `Expanded`를 사용하면 원래 자식의 너비는 중요하지 않게 되며 무시됩니다.

```dart
Widget example25() {
  // Row
  /// 자식 위젯들을 수평으로 나란히 배치, 부모 위젯의 크기
  /// 자식 위젯들은 제약 없이 각각의 크기에 맞게 그려짐

  // Expanded
  /// Expanded를 사용하면 원래 자식의 너비는 중요하지 않게 되며 무시하게 됨
  /// 자식 위젯이 자신이 차지할 수 있는 모든 가용 공간을 차지하도록 크기를 확장

  //	Center
  /// Center 위젯은 화면(부모) 전체 크기를 차지, 자식 위젯은 그 안에서 자유롭게 크기를 가질 수 있음.

  // Container
  /// Row에서 Expanded가 차지하지 않은 공간만큼의 너비를 가짐
  return Row(
    children: [
      Expanded(
        child: Center(
          child: Container(
            color: red,
            child: const Text(
              'This is a very long text that won\'t fit the line.',
              style: big,
            ),
          ),
        ),
      ),
      Container(color: green, child: const Text('Goodbye!', style: big)),
    ],
  );
}
```

### **Example 26**[#](https://docs.flutter.dev/ui/layout/constraints#example-26)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-26.png"/>

**If all of `Row`'s children are wrapped in `Expanded` widgets, each `Expanded` has a size proportional to its flex parameter, and only then each `Expanded` widget forces its child to have the `Expanded`'s width.**

`Row`의 모든 자식이 `Expanded` 위젯으로 감싸져 있다면, 각 `Expanded`는 자신의 flex 파라미터에 비례하는 크기를 가지며, 그런 다음 각 `Expanded` 위젯은 자식에게 자신의 너비를 강제합니다.

**In other words, `Expanded` ignores the preferred width of its children.**

다시 말해, `Expanded`는 자식의 선호 너비를 무시합니다.

```dart
Widget example26() {
  // Row
  /// 자식 위젯들을 수평으로 나란히 배치, 부모 위젯의 크기
  /// 자식 위젯들은 제약 없이 각각의 크기에 맞게 그려짐

  // Expanded
  /// Expanded를 사용하면 원래 자식의 너비는 중요하지 않게 되며 무시하게 됨
  /// 자식 위젯이 자신이 차지할 수 있는 모든 가용 공간을 차지하도록 크기를 확장
  /// 각 자식은 Expanded 위젯으로 감싸져 있기 때문에, 두 Expanded 위젯이 Row의 전체 너비를 동일하게 나눠 가짐
  return Row(
    children: [
      Expanded(
        child: Container(
          color: red,
          child: const Text(
            'This is a very long text that won\'t fit the line.',
            style: big,
          ),
        ),
      ),
      Expanded(
        child: Container(
          color: green,
          child: const Text(
            'Goodbye!',
            style: big,
          ),
        ),
      ),
    ],
  );
}
```

### **Example 27**[#](https://docs.flutter.dev/ui/layout/constraints#example-27)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-27.png"/>


**The only difference if you use `Flexible` instead of `Expanded`, is that `Flexible` lets its child have the same or smaller width than the `Flexible` itself, while `Expanded` forces its child to have the exact same width of the `Expanded`. But both `Expanded` and `Flexible` ignore their children's width when sizing themselves.**

`Flexible`을 사용할 때와 `Expanded`를 사용할 때의 유일한 차이점은, `Flexible`은 자식이 `Flexible` 자신과 같은 너비를 가지거나 더 작은 너비를 가질 수 있도록 허용하는 반면, `Expanded`는 자식이 `Expanded`와 정확히 동일한 너비를 가지도록 강제한다는 것입니다. 그러나 `Expanded`와 `Flexible` 모두 자신을 크기 조절할 때 자식의 너비를 무시합니다.

<aside>
💡 **Note**

**This means that it's impossible to expand `Row` children proportionally to their sizes. The `Row` either uses the exact child's width, or ignores it completely when you use `Expanded` or `Flexible`.**

이것은 `Row`의 자식들을 크기에 비례하여 확장하는 것이 불가능하다는 의미입니다. `Row`는 자식의 너비를 정확히 사용하거나, `Expanded`나 `Flexible`을 사용할 때 이를 완전히 무시합니다.

</aside>

```dart
Widget example27() {
  // Row
  /// 자식 위젯들을 수평으로 나란히 배치, 부모 위젯의 크기
  /// 자식 위젯들은 제약 없이 각각의 크기에 맞게 그려짐

  // Flexible
  /// 이 위젯은 자신이 차지할 수 있는 가용 공간을 최대한 활용
  /// 자식 위젯이 Flexible 위젯의 너비와 같거나 더 작은 너비를 가질 수 있도록 허용
  /// 이 예제에서는 각 Flexible 위젯은 Row의 가로 공간을 균등하게 나눠가짐

  /// Flexible: 자식이 공간을 더 적게 사용할 수 있도록 허용.
  /// Expanded: 자식이 가능한 모든 공간을 사용하도록 강제.
  return Row(
    children: [
      Flexible(
        child: Container(
          color: red,
          child: const Text(
            'This is a very long text that won\'t fit the line.',
            style: big,
          ),
        ),
      ),
      Flexible(
        child: Container(
          color: green,
          child: const Text(
            'Goodbye!',
            style: big,
          ),
        ),
      ),
    ],
  );
}
```

### **Example 28**[#](https://docs.flutter.dev/ui/layout/constraints#example-28)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-28.png"/>

**The screen forces the `Scaffold` to be exactly the same size as the screen, so the `Scaffold` fills the screen. The `Scaffold` tells the `Container` that it can be any size it wants, but not bigger than the screen.**

화면은 `Scaffold`가 화면과 정확히 동일한 크기를 가지도록 강제하므로, `Scaffold`는 화면을 가득 채웁니다. `Scaffold`는 `Container`에게 원하는 크기를 가질 수 있지만, 화면보다 커질 수는 없다고 알려줍니다.

<aside>
💡 **Note**

**When a widget tells its child that it can be smaller than a certain size, we say the widget supplies *loose* constraints to its child. More on that later.**

위젯이 자식에게 특정 크기보다 작아질 수 있다고 알려줄 때, 이를 *loose* constraints(느슨한 제약)라고 합니다. 이에 대해서는 나중에 더 자세히 설명하겠습니다.

</aside>

```dart
Widget example28() {
  // Container
  /// Container의 크기는 기본적으로 부모(여기서는 Scaffold)의 크기
  /// 자식 위젯의 크기에 따라 달라질 수 있음

  // Column
  /// 자식 위젯들을 수직으로 나란히 배치, 부모 위젯의 크기
  /// 자식 위젯들은 제약 없이 각각의 크기에 맞게 그려짐
  return Scaffold(
    body: Container(
      color: blue,
      child: const Column(
        children: [
          Text('Hello!'),
          Text('Goodbye!'),
        ],
      ),
    ),
  );
}
```

### **Example 29**[#](https://docs.flutter.dev/ui/layout/constraints#example-29)

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-29.png"/>

**If you want the `Scaffold`'s child to be exactly the same size as the `Scaffold` itself, you can wrap its child with `SizedBox.expand`.**

Scaffold의 자식이 Scaffold 자체와 정확히 동일한 크기를 가지도록 하려면, 자식을 SizedBox.expand로 감쌀 수 있습니다.

```dart
Widget example29() {
  // SizedBox.expand
  /// 자식 위젯이 부모의 크기와 동일한 크기를 가지도록 확장
  /// Container가 Scaffold의 크기와 정확히 동일한 크기를 가지도록 확장, Container는 화면 전체를 차지

  // Column
  /// 자식 위젯들을 수직으로 나란히 배치, 부모 위젯의 크기
  /// 자식 위젯들은 제약 없이 각각의 크기에 맞게 그려짐
  return Scaffold(
    body: SizedBox.expand(
      child: Container(
        color: blue,
        child: const Column(
          children: [
            Text('Hello!'),
            Text('Goodbye!'),
          ],
        ),
      ),
    ),
  );
}
```

# **Tight vs loose constraints**[#](https://docs.flutter.dev/ui/layout/constraints#tight-vs-loose-constraints)

**It's very common to hear that some constraint is "tight" or "loose", so what does that mean?**

“제약이 tight하다” 또는 “loose하다”는 말을 자주 듣게 되는데, 이는 무슨 뜻일까요?

## **Tight constraints**[#](https://docs.flutter.dev/ui/layout/constraints#tight-constraints)

**A *tight* constraint offers a single possibility, an exact size. In other words, a tight constraint has its maximum width equal to its minimum width; and has its maximum height equal to its minimum height.**

“Tight”한 제약은 단 하나의 가능성, 즉 정확한 크기를 제시합니다. 다시 말해, tight한 제약은 최대 너비가 최소 너비와 같고, 최대 높이가 최소 높이와 같습니다.

**An example of this is the `App` widget, which is contained by the [`RenderView`](https://api.flutter.dev/flutter/rendering/RenderView-class.html) class: the box used by the child returned by the application's [`build`](https://api.flutter.dev/flutter/widgets/State/build.html) function is given a constraint that forces it to exactly fill the application's content area (typically, the entire screen).**

이의 한 예로는, App 위젯이 있으며, 이는 RenderView 클래스에 의해 포함됩니다. 애플리케이션의 build 함수가 반환하는 자식이 사용하는 박스는 애플리케이션의 콘텐츠 영역(일반적으로 전체 화면)을 정확히 채우도록 강제하는 제약을 받습니다.

**Another example: if you nest a bunch of boxes inside each other at the root of your application's render tree, they'll all exactly fit in each other, forced by the box's tight constraints.**

또 다른 예로, 애플리케이션의 렌더 트리의 루트에 여러 박스를 중첩시키면, 모든 박스는 서로 꼭 맞게 됩니다. 이는 박스의 tight한 제약에 의해 강제됩니다.

**If you go to Flutter's `box.dart` file and search for the `BoxConstraints` constructors, you'll find the following:**

Flutter의 box.dart 파일로 가서 BoxConstraints 생성자를 검색해보면, 다음과 같은 내용을 찾을 수 있습니다:

```dart
BoxConstraints.tight(Size size)   
    : minWidth = size.width,     
      maxWidth = size.width,     
      minHeight = size.height,     
      maxHeight = size.height;
```

**If you revisit [Example 2](https://docs.flutter.dev/ui/layout/constraints#example-2), the screen forces the red `Container` to be exactly the same size as the screen. The screen achieves that, of course, by passing tight constraints to the `Container`.**

Example 2로 돌아가 보면, 화면은 빨간색 Container가 화면과 정확히 동일한 크기를 가지도록 강제합니다. 물론 화면은 Container에 tight한 제약을 전달하여 이를 달성합니다.

## **Loose constraints**[#](https://docs.flutter.dev/ui/layout/constraints#loose-constraints)

**A *loose* constraint is one that has a minimum of zero and a maximum non-zero.**

“Loose”한 제약은 최소값이 0이고 최대값이 0이 아닌 제약을 의미합니다.

**Some boxes *loosen* the incoming constraints, meaning the maximum is maintained but the minimum is removed, so the widget can have a minimum width and height both equal to zero.**

일부 박스는 들어오는 제약을 느슨하게(최대값은 유지하지만 최소값은 제거하여) 만듭니다. 이렇게 하면 위젯의 최소 너비와 높이가 모두 0이 될 수 있습니다.

**Ultimately, `Center`'s purpose is to transform the tight constraints it received from its parent (the screen) to loose constraints for its child (the `Container`).**

결국, Center의 목적은 부모(화면)로부터 받은 tight한 제약을 자식(Container)에게 느슨한 제약으로 변환하는 것입니다.

**If you revisit [Example 3](https://docs.flutter.dev/ui/layout/constraints#example-3), the `Center` allows the red `Container` to be smaller, but not bigger than the screen.**

Example 3으로 돌아가 보면, Center는 빨간색 Container가 더 작아질 수 있도록 허용하지만, 화면보다 커지지는 않게 합니다.

## **Unbounded constraints[#](https://docs.flutter.dev/ui/layout/constraints#unbounded-constraints)**

<aside>
💡 **Note**

**You might be directed here if the framework detects a problem involving box constraints. The `Flex` section below might also apply.**

프레임워크가 박스 제약과 관련된 문제를 감지하면 이 섹션으로 안내될 수 있습니다. 아래의 Flex 섹션도 관련될 수 있습니다.

</aside>

**In certain situations, a box's constraint is *unbounded*, or infinite. This means that either the maximum width or the maximum height is set to [`double.infinity`](https://api.flutter.dev/flutter/dart-core/double/infinity-constant.html).**

특정 상황에서는 박스의 제약이 unbounded(무한)일 수 있습니다. 이는 최대 너비나 최대 높이가 double.infinity로 설정되었음을 의미합니다.

**A box that tries to be as big as possible won't function usefully when given an unbounded constraint and, in debug mode, throws an exception.**

박스가 가능한 한 크게 되려고 하면 unbounded 제약을 받았을 때 제대로 기능하지 않으며, 디버그 모드에서는 예외를 발생시킵니다.

**The most common case where a render box ends up with an unbounded constraint is within a flex box ([`Row`](https://api.flutter.dev/flutter/widgets/Row-class.html) or [`Column`](https://api.flutter.dev/flutter/widgets/Column-class.html)), and within a scrollable region (such as [`ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html) and other [`ScrollView`](https://api.flutter.dev/flutter/widgets/ScrollView-class.html) subclasses).**

렌더 박스가 unbounded 제약을 받게 되는 가장 일반적인 경우는 플렉스 박스(Row 또는 Column) 안에 있거나 스크롤 가능한 영역(ListView 및 기타 ScrollView 하위 클래스) 내에 있는 경우입니다.

[**`ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html), for example, tries to expand to fit the space available in its cross-direction (perhaps it's a vertically-scrolling block and tries to be as wide as its parent). If you nest a vertically scrolling [`ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html) inside a horizontally scrolling `ListView`, the inner list tries to be as wide as possible, which is infinitely wide, since the outer one is scrollable in that direction.**

예를 들어, ListView는 교차 방향에서 사용할 수 있는 공간에 맞추기 위해 확장하려고 합니다(아마도 세로로 스크롤되는 블록이며 부모만큼 넓어지려고 합니다). 세로로 스크롤되는 ListView를 가로로 스크롤되는 ListView 안에 중첩시키면, 내부 리스트는 가능한 한 넓어지려고 시도하는데, 외부 리스트가 그 방향으로 스크롤 가능하기 때문에 무한히 넓어지게 됩니다.

**The next section describes the error you might encounter with unbounded constraints in a `Flex` widget.**

다음 섹션에서는 Flex 위젯에서 unbounded 제약으로 발생할 수 있는 오류에 대해 설명합니다.

## **Flex[#](https://docs.flutter.dev/ui/layout/constraints#flex)**

**A flex box ([`Row`](https://api.flutter.dev/flutter/widgets/Row-class.html) and [`Column`](https://api.flutter.dev/flutter/widgets/Column-class.html)) behaves differently depending on whether its constraint is bounded or unbounded in its primary direction.**

플렉스 박스(Row와 Column)는 주 방향에서 제약이 bounded인지 unbounded인지에 따라 다르게 동작합니다.

**A flex box with a bounded constraint in its primary direction tries to be as big as possible.**

주 방향에서 bounded 제약을 가진 플렉스 박스는 가능한 한 크게 되려고 합니다.

**A flex box with an unbounded constraint in its primary direction tries to fit its children in that space. Each child's `flex` value must be set to zero, meaning that you can't use [`Expanded`](https://api.flutter.dev/flutter/widgets/Expanded-class.html) when the flex box is inside another flex box or a scrollable; otherwise it throws an exception.**

주 방향에서 unbounded 제약을 가진 플렉스 박스는 그 공간에 자식을 맞추려고 합니다. 각 자식의 flex 값은 0으로 설정되어야 하며, 그렇지 않으면 플렉스 박스가 다른 플렉스 박스 안에 있거나 스크롤 가능 영역 내에 있을 때 Expanded를 사용할 수 없으며 예외를 발생시킵니다.

**The *cross* direction (width for [`Column`](https://api.flutter.dev/flutter/widgets/Column-class.html) or height for [`Row`](https://api.flutter.dev/flutter/widgets/Row-class.html)), must *never* be unbounded, or it can't reasonably align its children.**

교차 방향(Column의 너비 또는 Row의 높이)은 절대 unbounded가 되어서는 안 되며, 그렇지 않으면 자식을 합리적으로 정렬할 수 없습니다.

## **Learning the layout rules for specific widgets**[#](https://docs.flutter.dev/ui/layout/constraints#learning-the-layout-rules-for-specific-widgets)

**Knowing the general layout rule is necessary, but it's not enough.**

일반적인 레이아웃 규칙을 아는 것은 필요하지만, 충분하지는 않습니다.

**Each widget has a lot of freedom when applying the general rule, so there is no way of knowing how it behaves by just reading the widget's name.**

각 위젯은 일반 규칙을 적용할 때 많은 자유를 가지므로, 위젯의 이름만 보고 그 동작을 알 수는 없습니다.

**If you try to guess, you'll probably guess wrong. You can't know exactly how a widget behaves unless you've read its documentation, or studied its source-code.**

추측하려고 하면, 틀릴 가능성이 큽니다. 위젯이 어떻게 동작하는지 정확히 알기 위해서는 그 문서를 읽거나 소스 코드를 공부해야 합니다.

**The layout source-code is usually complex, so it's probably better to just read the documentation. However, if you decide to study the layout source-code, you can easily find it by using the navigating capabilities of your IDE.**

레이아웃 소스 코드는 일반적으로 복잡하므로, 문서를 읽는 것이 더 나을 것입니다. 그러나 레이아웃 소스 코드를 공부하기로 결정했다면, IDE의 탐색 기능을 사용하여 쉽게 찾을 수 있습니다.

**Here's an example:**

예를 들어:

- **Find a `Column` in your code and navigate to its source code. To do this, use `command+B` (macOS) or `control+B` (Windows/Linux) in Android Studio or IntelliJ. You'll be taken to the `basic.dart` file. Since `Column` extends `Flex`, navigate to the `Flex` source code (also in `basic.dart`).**
    
    코드에서 Column을 찾아 소스 코드로 이동합니다. 이를 위해 Android Studio나 IntelliJ에서 macOS의 경우 command+B, Windows/Linux의 경우 control+B를 사용합니다. basic.dart 파일로 이동하게 됩니다. Column이 Flex를 상속하므로 Flex의 소스 코드로 이동합니다(또한 basic.dart에 있습니다).
    
- **Scroll down until you find a method called `createRenderObject()`. As you can see, this method returns a `RenderFlex`. This is the render-object for the `Column`. Now navigate to the source-code of `RenderFlex`, which takes you to the `flex.dart` file.**
    
    스크롤하여 createRenderObject()라는 메서드를 찾습니다. 이 메서드는 RenderFlex를 반환합니다. 이는 Column의 렌더 객체입니다. 이제 RenderFlex의 소스 코드로 이동합니다. 이 작업은 flex.dart 파일로 이동시킵니다.
    
- **Scroll down until you find a method called `performLayout()`. This is the method that does the layout for the `Column`.**
    
    스크롤하여 performLayout()이라는 메서드를 찾습니다. 이 메서드는 Column의 레이아웃을 담당합니다.
    

<img src="https://docs.flutter.dev/assets/images/docs/ui/layout/layout-final.png"/>

---

### **Original article by Marcelo Glasberg**

**Marcelo originally published this content as [Flutter: The Advanced Layout Rule Even Beginners Must Know](https://medium.com/flutter-community/flutter-the-advanced-layout-rule-even-beginners-must-know-edc9516d1a2) on Medium. We loved it and asked that he allow us to publish in on docs.flutter.dev, to which he graciously agreed. Thanks, Marcelo! You can find Marcelo on [GitHub](https://github.com/marcglasberg) and [pub.dev](https://pub.dev/publishers/glasberg.dev/packages).**

Marcelo는 원래 이 내용을 Medium에 [Flutter: The Advanced Layout Rule Even Beginners Must Know](https://medium.com/flutter-community/flutter-the-advanced-layout-rule-even-beginners-must-know-edc9516d1a2)라는 제목으로 게시했습니다. 우리는 이 내용을 매우 좋아하여 docs.flutter.dev에 게시할 수 있도록 요청했고, Marcelo는 이를 기꺼이 허락해 주었습니다. 감사합니다, Marcelo! Marcelo는 [GitHub](https://github.com/marcglasberg)과 [pub.dev](https://pub.dev/publishers/glasberg.dev/packages)에서 찾아볼 수 있습니다.

**Also, thanks to [Simon Lightfoot](https://github.com/slightfoot) for creating the header image at the top of the article.**

또한, 이 글의 헤더 이미지를 제작한 [Simon Lightfoot](https://github.com/slightfoot)에게도 감사드립니다.
